var documenterSearchIndex = {"docs":
[{"location":"parameter/#Parameter-constraints","page":"Parameter constraints","title":"Parameter constraints","text":"","category":"section"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"Models are characterized by parameters (see Basic concepts and data types) whose values are modified during fitting until a convergence criterion is met, and the best fit values are identified.  In many cases, however, the parameters can not vary arbitrarily but should satisfy some constraints for their values to be meaningful.  GModelFit.jl supports the definition of constraints by fixing the parameter to a specific value, limiting the value in a user defined range, or by dynamically calculating its value using a mathematical expression involving other parameter values.  In the latter case the parameter is not free to vary in the fit since its actual value is determined by the patch constraint, hence it is dubbed a patched parameter.  Such unused parameter can optionally be repurposed as a new free parameter in a parametrized patch expression (see example below).","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"An important concept to bear in mind is that the GModelFit.Parameter structure provides two field for the associated numerical value:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"val: is the parameter value which is being varied by the solver during fitting.  The value set before the fitting is the guess value.  The value after fitting is the best fit one;\nactual: is the result of the patch expression evaluation, and the actual value used when evaluating a component via its evaluate! method.  Note that this value will be overwitten at each model evaluation, hence setting this field has no effect. The val and actual values are identical if no patch constraint has been defined.","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"A parameter constraint is defined by modifiying the fields of the corresponding GModelFit.Parameter structure. More specifically:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"to set a parameter to a specific value: set the val field to the numeric value and set the fixed field to true;\nto set a parameter value range: set one or both the low and high fields (default values are -Inf and +Inf respectively);","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"note: Note\nSome solvers do not handle parameter limits, hence parameter values are checked and possibly adjusted before fitting.","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"warning: Warning\nValues are not checked during the fitting process.  If you need a parameter to respect the allowed range you should use a suitable solver such as LsqFit or CMPFit.","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"to constraint a parameter to have the same numerical value as another one with the same name (but in another component): set the patch value to the component name (it must be a Symbol);\nto dynamically calculate an actual value using a mathematical expression depending on other parameter values: set the patch field to an anonymous function generated with the @fd macro.  The function must accept a single argument (actually a dictionary of components) and return a scalar number;\nto define a parametrized patch expression: create an anonymous function with the @fd macro with two arguments, the first has the same meaning as in the previous case, and the second is the free parameter value.  Note that patched parameter loses its original meaning, and becomes the parameter of the patch expression;\nto define a patch constraint involving parameters from other models in a Multi-dataset fitting scenario: simply use mpatch in place of patch, and the first argument to the Î»-function will be a vector with as many elements as the number of models in the Vector{Model} object.","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"The following examples show how to define constraints for each of the afore-mentioned cases.","category":"page"},{"location":"parameter/#Example","page":"Parameter constraints","title":"Example","text":"","category":"section"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"We will consider a model for a 1D domain consisting of the sum of a linear background component (named bkg) and two Gaussian-shaped features (l1 and l2):","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"using GModelFit\n\nmodel = Model(:bkg => GModelFit.OffsetSlope(1, 1, 0.1),\n              :l1 => GModelFit.Gaussian(1, 2, 0.2),\n              :l2 => GModelFit.Gaussian(1, 3, 0.4),\n              :main => SumReducer(:bkg, :l1, :l2))\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"Assume that, for the model to be meaningful, the parameters should satisfy the following constraints:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the bkg should have a fixed value of 1 at x=1, and a slope which is in the range [0:0.2]:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:bkg].offset.val = 1\nmodel[:bkg].offset.fixed = true\n\nmodel[:bkg].slope.low  = 0\nmodel[:bkg].slope.high = 0.2\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the normalization of l1 and l2 must be the same:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:l2].norm.patch = :l1\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the width of l2 must be twice that of l1 (patched parameter):","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:l2].sigma.patch = @fd m -> 2 * m[:l1].sigma\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the center of l2 must be at a larger coordinate with respect to the center of l1.  In this case we re-interpret the model[:l2].center parameter as the distance between the two centers, and create a parametrized patch expression to calculate the actual center value of l2:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:l2].center.patch = @fd (m, v) -> v + m[:l1].center\nmodel[:l2].center.val = 1   # guess value for the distance between the centers\nmodel[:l2].center.low = 0   # ensure [l2].center > [l1].center\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"We can fit the model against a mock dataset (see Generate mock datasets):","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"dom = Domain(0:0.1:5)\ndata = GModelFit.mock(Measures, model, dom)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"and plot the results with Gnuplot.jl:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"using Gnuplot\n@gp    coords(dom) values(data) uncerts(data) \"w yerr t 'Data'\" :-\n@gp :- coords(dom) model(dom) \"w l t 'Model'\"\nsaveas(\"example_patch1\") # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"(Image: )","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"See Multi-dataset fitting for an example on how to create a patch epression involving multiple models.","category":"page"},{"location":"builtincomp/#Built-in-components","page":"Built-in components","title":"Built-in components","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The GModelFit.jl provides several built-in components which may be used to build arbitrarily complex models.","category":"page"},{"location":"builtincomp/#OffsetSlope","page":"Built-in components","title":"OffsetSlope","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"An offset and slope component for 1D and 2D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D: GModelFit.OffsetSlope(offset, x0, slope);\n2D: GModelFit.OffsetSlope(offset, x0, y0, slopeX, slopeY);","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslope::Parameter: the slope of the linear function;\n2D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\ny0::Parameter: the Y coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslopeX::Parameter (only 2D): the slope of the plane along the X direction;\nslopeY::Parameter (only 2D): the slope of the plane along the Y direction;","category":"page"},{"location":"builtincomp/#Example","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a linear model using the OffsetSlope component\nmodel = Model(:linear => GModelFit.OffsetSlope(2, 0, 0.5))\n\n# Fit model against data\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The best fit parameter values can be retrieved with:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"println(\"Best fit values:\")\nprintln(\"b:  \", bestfit[:linear].offset.val, \" Â± \", bestfit[:linear].offset.unc)\nprintln(\"m:  \", bestfit[:linear].slope.val , \" Â± \", bestfit[:linear].slope.unc)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A similar example in 2D is as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a linear model using the OffsetSlope component\nmodel = Model(:plane => GModelFit.OffsetSlope(2, 0, 0, 0.5, 0.5))\n\n# Fit model against data\ndom = CartesianDomain(1:5, 1:5)\ndata = Measures(dom, [ 3.08403  3.46719  4.07612  4.25611  5.04716\n                       3.18361  3.88546  4.52338  5.12838  5.7864\n                       3.80219  4.90894  5.24232  5.06982  6.29545\n                       4.34554  4.68698  5.51505  5.69245  6.35409\n                       4.643    5.91825  6.18011  6.67073  7.01467], 0.25)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/#Polynomial","page":"Built-in components","title":"Polynomial","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A n-th degree polynomial function (n > 1) for 1D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructor is defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"GModelFit.Polynomial(p1, p2, ...); where p1, p2, etc. are the guess values for the coefficients of each degree of the polynomial.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are accessible as p0, p1, etc.","category":"page"},{"location":"builtincomp/#Example-2","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define domain and a linear model using the Polynomial component\nmodel = Model(GModelFit.Polynomial(2, 0.5))\n\n# Fit model against data\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"Note that the numerical results are identical to the previous example involving the OffsetSlope component.  Also note that the default name for a component (if none is provided) is :main.  To use a 2nd degree polynomial we can simply replace the :main component with a new one:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"model[:main] = GModelFit.Polynomial(2, 0.5, 1)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/#Gaussian","page":"Built-in components","title":"Gaussian","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A normalized Gaussian component for 1D and 2D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D: GModelFit.Gaussian(norm, center, sigma);\n2D: GModelFit.Gaussian(norm, centerX, centerY, sigma) (implies sigmaX=sigmaY, angle=0);\n2D: GModelFit.Gaussian(norm, centerX, centerY, sigmaX, sigmaY, angle);","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D:\nnorm::Parameter: the area below the Gaussian function;\ncenter::Parameter: the location of the center of the Gaussian;\nsigma::Parameter: the width the Gaussian;\n2D:\nnorm::Parameter: the volume below the Gaussian function;\ncenterX::Parameter: the X coordinate of the center of the Gaussian;\ncenterY::Parameter: the Y coordinate of the center of the Gaussian;\nsigmaX::Parameter: the width the Gaussian along the X direction (when angle=0);\nsigmaY::Parameter: the width the Gaussian along the Y direction (when angle=0);\nangle::Parameter: the rotation angle (in degrees) of the Gaussian.","category":"page"},{"location":"builtincomp/#Example-3","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a model with a single Gaussian component\nmodel = Model(GModelFit.Gaussian(1, 3, 0.5))\n\n# Fit model against data\ndata = Measures([0, 0.3, 6.2, 25.4, 37.6, 23., 7.1, 0.4, 0], 0.6)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A very common problem is to fit the histogram of a distribution with a Gaussian model.  The following example shows how to fit such Gaussian model to a distribution generated with Random.randn, and how to plot the results using Gnuplot.jl:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using Random, GModelFit, Gnuplot\n\n# Calculate histogram of the distribution\nhh = hist(randn(10000), bs=0.25)\n\n# Define domain and data and fit a model\ndom = Domain(hist_bins(hh, side=:center, pad=false))\ndata = Measures(dom, hist_weights(hh, pad=false), 1.)\nmodel = Model(GModelFit.Gaussian(1e3, 0, 1))\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"@gp hh coords(dom) bestfit() \"w l t 'Model' lw 3\"\nsaveas(\"gaussian\") # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"(Image: )","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A similar problem in 2D can be handled as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using Random, GModelFit, Gnuplot\n\n# Calculate histogram of the distribution\nhh = hist(1 .+ randn(10000), 2 .* randn(10000))\n\n# Define domain and data and fit a model\ndom = CartesianDomain(hist_bins(hh, 1), hist_bins(hh, 2))\ndata = Measures(dom, hist_weights(hh) .* 1., 1.)\nmodel = Model(GModelFit.Gaussian(1e3, 0, 0, 1, 1, 0))\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/#FComp","page":"Built-in components","title":"FComp","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"As anticipated in Basic concepts and data types any Julia function can be used as a component to evaluate.  The corresponding component type is FComp, whose constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"FComp(funct::Function, deps=Symbol[]; par1=guess1, par2=guess2, ...)\nFComp(funct::FunctDesc)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"In the first constructor funct is the Julia function, deps is a vector of dependencies (either the domain dimensions or other component names) and par1, par2 etc. are the named parameters with their corresponding initial guess values.","category":"page"},{"location":"builtincomp/#Example-4","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a simple Julia function to evaluate a linear relationship\nmyfunc(x, b, m) = b .+ x .* m\n\n# Define a model with a `FComp` wrapping the previously defined function.\n# Also specify the initial guess parameters.\nmodel = Model(:linear => GModelFit.FComp(myfunc, [:x], b=2, m=0.5))\n\n# Fit model against a data set\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"In the second constructor a GModelFit.FunctDesc object is accepted, as generated by the @fd macro).  The function is typically a mathematical expression combining any number of parameters and/or other component evaluations within the same model.  The expression should be given in the form:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"@fd (x, [y, [further domain dimensions...],]\n    [comp1, [comp2, [further components ...],]]\n    [par1=guess1, [par2=guess2, [further parameters]]]) ->\n    (mathematical expression)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"where the mathematical expression returns a Vector{Float64} with the same length as the model domain.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The previous example can be rewritten as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a linear model (with initial guess parameters)\nmodel = Model(:linear => @fd (x, b=2, m=0.5) -> (b .+ x .* m))\n\n# Fit model against data\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"Note that a FComp component can be added to a model without explicitly invoking its constructor when the @fd macro is used.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The evaluation of a FComp component may also involve the outcomes from other components. Continuing from previous example, whose fit was clearly a poor one, we may add a quadratic term to the previously defined linear component:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"model[:quadratic] = @fd (x, linear, p2=1) -> (linear .+ p2 .* x.^2)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The keywords given when defining the function are interpreted as component parameters, hence their properties can be retrieved with:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"println(\"Best fit values:\")\nprintln(\"b:  \", bestfit[:linear].b.val    , \" Â± \", bestfit[:linear].b.unc)\nprintln(\"m:  \", bestfit[:linear].m.val    , \" Â± \", bestfit[:linear].m.unc)\nprintln(\"p2: \", bestfit[:quadratic].p2.val, \" Â± \", bestfit[:quadratic].p2.unc)","category":"page"},{"location":"builtincomp/#SumReducer","page":"Built-in components","title":"SumReducer","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A component calculating the element-wise sum of a number of other components.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The SumReducer constructor is defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"SumReducer(args::AbstractSet{Symbol})\nSumReducer(args::Vector{Symbol})\nSumReducer(args::Vararg{Symbol})","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"where the Symbols represent the component names","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The SumReducer component has no parameter.","category":"page"},{"location":"builtincomp/#Example-5","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define domain and a linear model (with initial guess parameters)\nmodel = Model(:linear => @fd (x, b=2, m=0.5) -> (b .+ x .* m))\n\n# Add a quadratic component to the model\nmodel[:quadratic] = @fd (x, p2=1) -> (p2 .* x.^2)\n\n# The total model is the sum of `linear` and `quadratic`\nmodel[:main] = SumReducer(:linear, :quadratic)\n\n# Fit model against data\ndom = Domain(1:5)\ndata = Measures(dom, [4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"concepts/#Basic-concepts-and-data-types","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"","category":"section"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"In order to exploit the GModelFit.jl model expressiveness a few concepts need to be introduced, along with their associated data types:","category":"page"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Domain: an N-dimensional grid of points associated to empirical measures, and used to evaluate a model.  It is analogous to the independent varible vecx in the f(vecx) notation. It is represented by either:\na Domain{N} object for linear domains, where the coordinates for each of the N dimensions are explicitly specified for all the points;\nor a CartesianDomain{N} object where the coordinates are specified for each of the N axis and the coordinates for all points are obtained as the cartesian product of all the axes.  A cartesian domain is internally transformed into a linear one when needed;\nA domain object (either linear or cartesian) is required as first argument for the Measures constructor (see below).\nMeasures: a container for the N-dimensional empirical data and their associated 1sigma Gaussian uncertainties, represented by an object of type Measures{N} (further options may be available in the future, such as Poisson counts);\nModel component: the atomic building block of a (potentially complex) model, it is essentially a function used to map a Domain or CartesianDomain object into a Vector{Float64} representing the component evaluation.  A component is a structure inheriting from GModelFit.AbstractComponent and is typically characterized by one or more parameters (see below).  The GModelFit.jl package provides several Built-in components, and new ones can be implemented by the user (see Custom components).  The memoization mechanism operates at the component level and aims to avoid unnecessary re-evaluation of the component if none of its parameter values or its dependencies has changed since last evaluation.  Also note that all components in a model always share the same evaluation domain;\nParameter: a single floating point number characterizing a specific aspect for the evaluation of a component (e.g. the slope of a power law, the width of a Gaussian profile, etc.). The parameter values are automatically varied during the fitting process until the residuals between the global model evaluation and the empirical data are minimized.  A parameter can be fixed to a specific value, limited in an interval, and/or be dynamically calculated (patched) according to the values of other parameters.  All parameters are represented by an object of type GModelFit.Parameter;\nModel: is the overall model description, whose evaluation is supposed to be compared to a single Measures object and whose parameters are varied during fitting to reduce the residuals.  Internally, a model is implemented as a dictionary containing one or more components, each identified by a unique Symbol name (see Model);\nComponent dependencies and main component: the evaluation of a component, say A, may use the outcome of another component, say B, to calculate its output, thus inducing a dependency between the two. In this case we say that A depends on B, and therefore B needs to be evaluated before A (circular dependencies are not allowed, and would raise an error if attempted).  The dependencies are automatically identified, and the last component being evaluated is dubbed main component since its output represent the overall model evaluation;\nMulti-model: a Vector{Model} containing two or more models, suitable to be compared to a corresponding Vector{Measures} to perform Multi-dataset fitting;\nInstrument response: is a description of the instrumental artifacts or modifications being introduced in the data by the instrument used to collect them.  A comparison between model and data without taking such effects into account may bias the parameter estimates, or be impossible (e.g. because model and data are defined on different domains).  GModelFit.jl implements forward fitting, namely the capability to fold a model with an instrument response before comparing it to the data.  Instrument responses are strongly dependent on the instrument being used hence GModelFit.jl does not provide any specific implementation, except for the GModelFit.IdealInstrument response representing an ideal instrument where unfolded and folded models are identical.  An instrument response is represented by a structure inheriting from GModelFit.AbstractInstrumentResponse and the details to implement custom ones are available in Instrument response;\nSolver: the GModelFit.jl package provides just the tools to define and manipulate a model, but the actual fitting (namely, the minimization of the residuals) is performed by an external solver library.  Currently available solvers are:\nLsqFit: a pure-Julia solver;\nCMPFit: a C solver wrapped in a Julia package;\nNonlinearSolve.","category":"page"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"LsqFit is the default choice (unless otherwise specified in the fit() or fit!() function call).","category":"page"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Model snapshot: the best fit model, as well as the best fit parameter values and associated uncertainties, are returned by the fit() function as a GModelFit.ModelSnapshot structure, namely a frozen snapshot of the evaluation of a Model object on a given Domain.  Components, parameters and evaluations outcomes are accessed in exactly the same way on both Model and ModelSnapshot objects, the only difference being that the latter can nott be re-evaluated on different parameter values.\nFit summary: the fit statistic, namely the quantity minimized during the fitting process, as well as other information such as number of data points, number of free parameters, and elapsed time are returned by the fit() and fit!() functions in a GModelFit.FitSummary structure;\nfunction descriptor: GModelFit.jl uses standard Julia function in two different contexts:\nto calculate the value of a Parameter as a function of other Parameter's values. In this case the parameters are said to be patched, or linked, since there is a constraint between their values.  Two (or more) parameters may be patched within the same model, or across models when performing Multi-dataset fitting;\nto define a model component using a standard Julia mathematical expression involving Parameters values or other components;\nTo use a standard function in this fashion it should be wrapped into a GModelFit.FunctDesc object which allows both to invoke the function itself, as well as to provide a string representation for display purposes.  In order to create a function descriptor object it typically is much easier to invoke the @fd macro rather than the FunctDesc constructor.","category":"page"},{"location":"ir/#Instrument-response","page":"Intrument response","title":"Instrument response","text":"","category":"section"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"An instrument response allows to convert the unfolded model into a form suitable to be compared with empirical data.  This may also involve a remapping from the unfolded model domain (namely, the domain where all model components are evaluated) to the folded model domain (namely, the domain where the measurements are evaluated).","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"GModelFit.jl provides only one built-in instrument response named GModelFit.IdealInstrument representing an ideal instrument where the folded and unfolded models are identical.  No attempt is made to provide further instrument responses since these are strongly dependent on the instrument being used for the measurements.","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"It is however possible to implement a custom instrument responses as follows:","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"Define a new structure inheriting from GModelFit.AbstractInstrumentResponse;\nOptionally implement a prepare!(::AbstractInstrumentResponse, ::AbstractDomain) method aimed to pre-compute quantities to be used during model evaluation.  This step is not mandatory, and the default implementation for prepare! does nothing;\nImplement an unfolded_domain method whose purpose is to return the domain for the unfolded model;\nImplement an apply_ir! method whose purpose is to apply the instrument response on an unfolded model evaluation, and to populate the vector of the folded model;\nUse set_IR! to select the proper instrument response.","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"As an example we copy here the implementation for the IdealInstrument:","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"# Define IdealInstrument structure\nstruct IdealInstrument <: AbstractInstrumentResponse\nend\n\n# Method to retrieve the unfolded model domain.  In this case it simply is the same as the folded domain.\nunfolded_domain(IR::IdealInstrument, folded_domain::AbstractDomain) = folded_domain\n\n# Method to apply the instrument response.  In this case it simply copies all values from the \"unfolded\"\n# vector to the \"folded\" one.\nfunction apply_ir!(IR::IdealInstrument,\n                   folded_domain::AbstractDomain  , folded::Vector,\n                   unfolded_domain::AbstractDomain, unfolded::Vector)\n    folded .= unfolded\nend","category":"page"},{"location":"ir/#Example","page":"Intrument response","title":"Example","text":"","category":"section"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"A more complex example is as follows: suppose your instrument has a limited resolution and responds to a narrow signal by producing a rather broad feature in the data.  Also assume that your data are sampled on a non-regular grid, while you need to evaluate the unfolded model on a regular grid.","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"The following code shows how to implement an instrument response which:","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"uses an evenly spaced grid for unfolded model evaluation;\nconvolve the unfolded model with a kernel representing the finite resolution of the instrument;\ninterpolate the evaluation onto the irregular grid where data are available.","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"using GModelFit, Gnuplot, DSP, Interpolations\n\n# Import relevant methods\nimport GModelFit: unfolded_domain, apply_ir!\n\n# Create the new structure representing the instrument response\nstruct MyInstrument <: GModelFit.AbstractInstrumentResponse\n    kernel::Vector{Float64}\n    function MyInstrument()\n        # Convolution kernel representing the limited resolution of the instrument\n        # (an ideal instrument would have kernel = [1])\n        kernel = [0.0, 0.0, 0.0, 0.0, 0.002, 0.009, 0.027, 0.065, 0.121, 0.176, 0.199,\n                  0.176, 0.121, 0.065, 0.027, 0.009, 0.002, 0.0, 0.0, 0.0, 0.0]\n        return new(kernel)\n    end\nend\n\n# Return the evenly-spaced domain to be used for evalation of the unfolded model\nunfolded_domain(IR::MyInstrument, folded_domain::GModelFit.AbstractDomain) = Domain(4.5:0.1:6.5)\n\n# Apply instrument response\nfunction apply_ir!(IR::MyInstrument,\n                   folded_domain::GModelFit.AbstractDomain, folded::Vector,\n                   unfolded_domain::GModelFit.AbstractDomain, unfolded::Vector)\n    # Convolve with instrument response\n    d = div(length(IR.kernel)-1, 2)\n    y = conv(unfolded, IR.kernel)[d+1:end-d]\n\n    # Interpolate on the irregular grid of the folded domain\n    folded .= linear_interpolation(coords(unfolded_domain), y)(coords(folded_domain))\nend\nnothing # hide","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"The code to use the above defined MyInstrument instrument response is as follows:","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"# Create empirical data structures\ndom = Domain([4.898, 4.997, 5.054, 5.09, 5.142, 5.229, 5.239, 5.429, 5.592, 5.629, 5.829, 5.882, 5.946, 5.99, 6.181])\ndata = Measures(dom, [3.009, 3.017, 3.251, 3.209, 3.568, 4.118, 4.487, 4.837, 4.428, 4.396, 3.78, 3.443, 3.237, 3.28, 3.032], 0.12)\n\n# Define a model and set MyInstrument as instrument response\nmodel = Model(@fd (x, Î¼=5.5, Ï=0.1, off=3) -> (@. off + exp(-0.5 * ((x - Î¼) / Ï)^2) / sqrt(2pi) / Ï))\nset_IR!(model, MyInstrument())\n\n# Fit data to the model\nbestfit, fsumm = fit(model, data)","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"From the plot we can see that the feature in the data is broader than the actual feature in the unfolded model (identified by the main component):","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"@gp bestfit data\nsaveas(\"ir_example\"); # hide","category":"page"},{"location":"ir/","page":"Intrument response","title":"Intrument response","text":"(Image: )","category":"page"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Generate-mock-datasets","page":"Miscellaneous","title":"Generate mock datasets","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"In some case it is useful to test a model for robustness before the emprical data are available for fitting.  This can be achieved via the GModelFit.mock() function, whose purpose is to generate a mock dataset which simulates a measurement process by adding random noise to the foreseen ground-truth.","category":"page"},{"location":"misc/#Example","page":"Miscellaneous","title":"Example","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\n\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\n\n# Generate a mock dataset on a specific domain\ndom = Domain(1:0.1:50)\ndata = GModelFit.mock(Measures, model, dom, seed=1)\n\n# Fit model against the mock dataset\nbestfit, fsumm = fit(model, data)","category":"page"},{"location":"misc/#Serialization","page":"Miscellaneous","title":"Serialization","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"A few structures, namely GModelFit.ModelSnapshot, GModelFit.FitSummary and Measures{N}, as well as Vector(s) of such structures can be serialized, i.e. stored in a file using a dedicated JSON format.  The structures can lated be de-serialized in a separata Julia session without the need to re-run the fitting process used to create them in the first place.","category":"page"},{"location":"misc/#Example-2","page":"Miscellaneous","title":"Example","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"In the following we will generate a few GModelFit.jl objects and serialized them in a file.","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\n\ndom = Domain(1:0.1:50)\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\ndata = GModelFit.mock(Measures, model, dom, seed=1)\nbestfit, fsumm = fit(model, data)\n\n# Serialize objects and save in a file\nGModelFit.serialize(\"save_for_future_use.json\", bestfit, fsumm, data)\nprintln(); # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"The same objects can be de-serialized in a different Julia session:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\nbestfit, fsumm, data = GModelFit.deserialize(\"save_for_future_use.json\")","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"warning: Warning\nThe solver_retval field in the GModelFit.FitSummary structure can not be serialized.  Upon deserialization it will contain nothing.","category":"page"},{"location":"misc/#Quick-plot-(1D)","page":"Miscellaneous","title":"Quick plot (1D)","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"The GModelFit.jl package implements Gnuplot.jl recipes to display plots of Measures{1} and ModelSnapshot objects., e.g.:","category":"page"},{"location":"misc/#Example-3","page":"Miscellaneous","title":"Example","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Create a model, a mock dataset and run a fit:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\n\ndom = Domain(0:0.01:5)\nmodel = Model(:bkg => GModelFit.OffsetSlope(1, 1, 0.1),\n              :l1 => GModelFit.Gaussian(1, 2, 0.2),\n              :l2 => GModelFit.Gaussian(1, 3, 0.4),\n              :main => SumReducer(:bkg, :l1, :l2))\ndata = GModelFit.mock(Measures, model, dom)\nbestfit, fsumm = fit(model, data)\nprintln(); # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"A plot of the dataset and of the best fit model can be simply obtained with","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using Gnuplot\n@gp data bestfit\nsaveas(\"gnuplot1\") # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"(Image: )","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"You may also specify axis range, labels, title, etc. using the standard Gnuplot.jl keyword syntax, e.g.:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using Gnuplot\n@gp xr=[1, 4.5] xlabel=\"Wavelength\" ylab=\"Flux\" \"set key outside\" data bestfit\nsaveas(\"gnuplot2\") # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"(Image: )","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The GModelFit.jl main purpose is to act as an high-level interface between the user and the underlying solver. Currently supported solvers are:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"LsqFit (default);\nCMPFit;\nNonlinearSolve.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"More solvers may be added in the future.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"To choose a specific solver add a third argument to the fit() or fit!() functions, e.g. ","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"fit(model, data)                 # use default solver: lsqfit\nfit(model, data, cmpfit())       # use CMPFIT solver\nfit(model, data, TrustRegion())  # use NonlinearSolve.TrustRegion solver","category":"page"},{"location":"solvers/#Examples","page":"Solvers","title":"Examples","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using GModelFit\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\ndata = GModelFit.mock(Measures, model, Domain(1:0.1:50), seed=1)\nbestfit, fsumm = fit(model, data, lsqfit())","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"or","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"bestfit, fsumm = fit(model, data, cmpfit())","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"or","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using NonlinearSolve\nbestfit, fsumm = fit(model, data, NewtonRaphson())","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The above solvers typically provide the same results, although in some complex case the results may differ.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"warning: Warning\nUnlike LsqFit and CMPFIT, the solvers from NonlinearSolve do not provide best fit parameter uncertainties.","category":"page"},{"location":"solvers/#The-cmpfit()-solver","page":"Solvers","title":"The cmpfit() solver","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"The cmpfit() solver allows to specify several options to fine-tune the solver behaviour.  Specifically:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"the CMPFit.Config structure allows to specify the convergence criteria, the maximum number of iterations, etc. (see the \"CONFIGURING MPFIT()\" section here;\nthe ftol_after_maxiter allows to specify a threshold on the relative difference in fit statistics before and after the mpfit() execution.  If the latter terminates because the maximum number of iterations has been reached, and the relative difference in fit statistics is still greater than ftol_after_maxiter the minimization process will continue.  E.g.:\nusing GModelFit\ndom = Domain(1:0.1:50)\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\ndata = GModelFit.mock(Measures, model, dom, seed=1)\n\n# Set solver options\nsolver = GModelFit.cmpfit()\nsolver.config.maxiter = 1\nsolver.ftol_after_maxiter = 1e-8\n\n# Run the fit\nmodel[:main].T.val = 10  # guess value, purposely far from true one\nbestfit, fsumm = fit(model, data, solver)\nprintln(); # hide","category":"page"},{"location":"multifit/#Multi-dataset-fitting","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"","category":"section"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"GModelFit.jl is able to simultaneously fit several models against a corresponding number of datasets, while placing constraints among the models. Typical use cases are:","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"a single phenomenon is observed with two (or more) instruments/detectors;\na single phenomenon is observed at different times;","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"Fitting multiple datasets simultaneously may provide tighter constraints on the best fit parameters under the assumption that the models are somehow related, i.e. that their parameters are constrained (or patched).","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"To perform a multi-dataset fitting we should create one Model for each dataset in the usual way, collect them in a Vector{Model}, and define patch constraints among models.   The following example shows how to fit two Gaussian curves under the hypotesis that the center and normalization parameters are the same:","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"using GModelFit\n\n# Create individual models and the Vector{Model} container\nmodel1 = Model(GModelFit.Gaussian(1, 0., 1.))\nmodel2 = Model(GModelFit.Gaussian(1, 0., 1.))\nmulti = [model1, model2]\n\n# Patch parameters\nmulti[2][:main].norm.mpatch   = @fd m -> m[1][:main].norm\nmulti[2][:main].center.mpatch = @fd m -> m[1][:main].center\n\n# Create datasets and fit\ndom = Domain(-5.:5)\ndata1 = Measures(dom, [-0.006,  0.015,  0.001,  0.049,  0.198,  0.430,  0.226,  0.048,  0.017, -0.001, -0.006], 0.04)\ndata2 = Measures(dom, [-0.072, -0.033, -0.070,  0.108,  0.168,  0.765,  0.113, -0.054,  0.032,  0.013,  0.015], 0.04)\nbestfit, fsumm = fit(multi, [data1, data2])\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"The best fit models and values are returned as a Vector{ModelSnapshot} in bestfit, i.e.:","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"println(\"Width of Gaussian 1: \", bestfit[1][:main].sigma.val, \" Â± \", bestfit[1][:main].sigma.unc)\nprintln(\"Width of Gaussian 2: \", bestfit[2][:main].sigma.val, \" Â± \", bestfit[2][:main].sigma.unc)\nprintln(\"Reduced Ï^2: \", fsumm.fitstat)","category":"page"},{"location":"customcomp/#Custom-components","page":"Custom components","title":"Custom components","text":"","category":"section"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"Besides the Built-in components, the user may define any number of custom components.  The latter are structures satisfying the following constraints:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"They should inherit from GModelFit.AbstractComponent;\nThe component parameters (if present) must be defined as fields with type Parameter, e.g.:\nstruct MyComponent <: AbstractComponent\n    param1::Parameter\n    param2::Parameter\n    ...\nend\nAlternatively, the parameters may be specified as a single field of type OrderedDict{Symbol, Parameter} (see the Polynomial component for an example).  The structure may also contain further fields of any type;\nThe GModelFit.evaluate! function should be extended with a dedicated method to evaluate the component, as shown below.","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"Optionally, the user may choose to extend also the following functions:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"GModelFit.dependencies: to specify the list of the component dependencies.  If not defined, the fallback method returns Symbol[];\nGModelFit.prepare!: to pre-compute quantities depending on the evaluation domain.  If not defined, the fallback method does nothing;","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The following example shows how to define a custom component and implement all of the above methods:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"using GModelFit\nimport GModelFit: prepare!, dependencies, evaluate!\n\nstruct MyComponent <: GModelFit.AbstractComponent\n    param1::GModelFit.Parameter\n\n    function MyComponent(param1)\n        println(\" -> call to MyComponent constructor;\")\n        new(GModelFit.Parameter(param1))\n     end\nend\n\nfunction dependencies(comp::MyComponent)\n    println(\" -> call to dependencies()\")\n    return Symbol[]\nend\n\nfunction prepare!(comp::MyComponent, domain::AbstractDomain)\n    println(\" -> call to prepare!()\")\nend\n\nfunction evaluate!(comp::MyComponent, domain::AbstractDomain, output::Vector, param1)\n    println(\" -> call to evaluate!() with parameter value: \", param1)\n    output .= param1\nend\n\nprintln() # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"note: Note\nIn the vast majority of cases there is no need to extend the dependencies and prepare! functions. The only mandatory implementaion is the one for evaluate!.","category":"page"},{"location":"customcomp/#Life-cycle-of-a-component","page":"Custom components","title":"Life cycle of a component","text":"","category":"section"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The life cycle of a component is as follows:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The component is created by invoking its constructor;\nIn order to prepare the data structures for component evaluation the following functions are invoked:\nGModelFit.dependencies;\nGModelFit.prepare!;\nFinally the GModelFit.evaluate! method is invoked to actually evaluate the component.","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"A quick way to evaluate a component on a Domain is as follows:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"# Create a domain and a component\ndom = Domain(1:4)\ncomp = MyComponent(1)\n\n# Evaluate component on the domain\ncomp(dom)\nnothing  # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"It is also possible to evaluate the component specifying a custom value for the component:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"comp(dom, param1=4.5)\nnothing  # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"A similar life cycle is observed when the componens is evaluated from within a Model:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"# Create a domain and a model\ndom = Domain(1:4)\nmodel = Model(:mycomp => MyComponent(1))\n\n# Evaluate model on the domain\nmodel(dom)\nnothing  # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"It is possible to modify the param1 and re-evaluate with:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"model[:mycomp].param1.val = 4.5\nmodel(dom)\nnothing  # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"Finally, when fitting a model the prepare! is invoked only once.  The dependencies function is invoked a number of times to create the internal data structures, while evaluate! is invoked each time the solver needs to probe the model on a specific set of parameter values:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"bestfit, fsumm = fit(model, Measures(dom, [9., 9., 9., 9.], 1.))\nnothing  # hide","category":"page"},{"location":"customcomp/#Complete-example","page":"Custom components","title":"Complete example","text":"","category":"section"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"A common case is to compare empirical data with a numerically evaluated theoretical model, possibly defined on a different grid with respect to the empirical one.  An interpolation is therefore required in order to compare the model to the data.","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"Let's assume the theoretical model is defined as follows:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"theory_x = 0.:10\ntheory_y = [0, 0.841, 0.909, 0.141, -0.757, -0.959, -0.279, 0.657, 0.989, 0.412, -0.544]\nprintln() # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"while the empirical data are:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"obs_x = [0.500, 2.071, 3.642, 5.212, 6.783, 8.354, 9.925]\nobs_y = [2.048, 3.481, 1.060, 0.515, 3.220, 4.398, 1.808]\nprintln() # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The following example shows how to implement a component which interpolates a theoretical model onto a specific empirical domain, with the only parameter being a global scaling factor:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"using GModelFit, Interpolations\nimport GModelFit: prepare!, evaluate!\n\n# Define the component structure and constructor\nstruct Interpolator <: GModelFit.AbstractComponent\n    theory_x::Vector{Float64}\n    theory_y::Vector{Float64}\n    interp_y::Vector{Float64}  # will contain the interpolated values\n    scale::GModelFit.Parameter\n\n    function Interpolator(theory_x, theory_y)\n        scale = GModelFit.Parameter(1)\n        scale.low = 0                  # ensure scale parameter is positive\n        interp_y = Vector{Float64}()   # this will be populated in prepare!()\n        return new(theory_x, theory_y, interp_y, scale)\n    end\nend\n\n# Component preparation: invoked only once to precompute quantities\n# and allocate evaluation buffer\nfunction prepare!(comp::Interpolator, domain::AbstractDomain{1})\n    # Pre-compute interpolation on the empirical domain\n    itp = linear_interpolation(comp.theory_x, comp.theory_y)\n    append!(comp.interp_y, itp(coords(domain)))\nend\n\n# Component evaluation (apply scaling factor)\nfunction evaluate!(comp::Interpolator, ::AbstractDomain{1}, output,\n                   scale)\n    output .= scale .* comp.interp_y\nend\nprintln() # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The following code shows how to prepare a Model including the interpolated theoretical model, and to take into account the possible background introduced by the detector used to obtain empirical data:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"model = Model(:theory => Interpolator(theory_x, theory_y),\n              :background => GModelFit.OffsetSlope(1., 0., 0.2),\n              :main => SumReducer(:theory, :background))\n\ndata = Measures(Domain(obs_x), obs_y, 0.2)\nbestfit, fsumm = fit(model, data)\nshow((bestfit, fsumm)) # hide","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Exported-symbols","page":"API","title":"Exported symbols","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The list of GModelFit.jl exported symbols is as follows:","category":"page"},{"location":"api/#GModelFit.CartesianDomain","page":"API","title":"GModelFit.CartesianDomain","text":"CartesianDomain{N}\n\nAn object representing a model, or a dataset, N-dimensional cartesian domain (i.e. a grid).\n\nAvailable constructors:\n\nDomain(axis...): each argument is a vector containing the coordinates on a given axis (arguments may have different lengths);\nDomain(lengths...): returns a N-dim CartesianDomain object whose axis lengths are specified in the arguments.\n\nNote that a CartesianDomain requires at least 2 dimensions.\n\nCoordinates for all points along a given axis can be obtained with the coords() function, while the coordinates of the grid can be obtained with axis().\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Domain","page":"API","title":"GModelFit.Domain","text":"Domain{N}\n\nAn object representing a N-dimensional linear domain.\n\nAvailable constructors:\n\nDomain(coords...): each argument is a vector, one for each dimension (all arguments must have same lengths);\nDomain(length): returns a 1-dim Domain object of the given length.\n\nCoordinates for all points along a given axis can be obtained with the coords function.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Measures","page":"API","title":"GModelFit.Measures","text":"Measures{N}\n\nAn object representing a set of empirical measurements (with Gaussian uncertainties) as measured on a specific domain.\n\nAvailable constructors:\n\nMeasures(domain::Domain{N},           values::AbstractVector{T},           uncerts::AbstractVector{T}) where {T <: AbstractFloat, N}\nMeasures(domain::CartesianDomain{N},           values::AbstractArray{T, N},           uncerts::AbstractArray{T, N}) where {T <: AbstractFloat, N}\nMeasures(values::AbstractVector, uncerts)\n\nIn the above constructor methods the last argument may also be a scalar value, to set the same uncertainty for all the measurements. The method accepting a CartesianDomain requires arrays with at least 2 dimensions.  In the last constructor the Domain object is automatically built depending on the length of the values vector.\n\nThe domain, values and uncertainties for a Measures object can be retrieved using the domain, values and uncerts functions respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Model","page":"API","title":"GModelFit.Model","text":"Model\n\nA structure containing a model description.\n\nConstructor is: Model(components...).  Components may be specified as:\n\na single Dict{Symbol, AbstractComponent}, where the keys are the names and the values the component objects;\na single component (the default :main is automatically assigned);\na single FunctDesc which will be wrapped into an FComp component and a default name will be assigned (:main);\none or more Pair{Symbol, AbstractComponent}, where the first element is the name and the second is the component.\n\nYou may access the individual component in a Model using the indexing syntax, as if it was a Dict{Symbol, AbstractComponent}.  Also, you may add new components to a Model after it has been created using the same syntax.  Finally, you may use the keys() and haskey() functions with their usual meanings.\n\nIndividual components may be freezed (i.e. have all its parameters fixed during fitting, despite the individual Parameter settings) or thawed using the freeze!() and thaw!() functions.  Use the isfreezed() function to check if a component is freezed.\n\nThe main component, i.e. the one whose evaluation corresponds to the overall model evaluation, is automatically identified by analyzing the component dependencies.  However a specific component may be forced to be the main one by invoking select_maincomp!.\n\nThe most important function for a Model object is fit() which allows to fit the model against an empirical dataset.  The fit!() function has the same purpose, with the only difference that it stores the best fit parameter values into the original Model object.\n\nThe model and all component evaluation can be evaluated has if they were a function by simply passing a Domain object.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.@fd","page":"API","title":"GModelFit.@fd","text":"@fd expr\n\nMacro to generate a FunctDesc object using the same syntax as for a standard Julia anonymous function.\n\nExample\n\njulia> f = @fd (x, p=0) -> x + p\n\njulia> f(1, 2)\n3\n\n\n\n\n\n","category":"macro"},{"location":"api/#GModelFit.axis","page":"API","title":"GModelFit.axis","text":"axis(d::CartesianDomain, dim::Integer)\n\nReturns the coordinates of the grid along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.comptype","page":"API","title":"GModelFit.comptype","text":"comptype(model::Model, cname::Symbol)\n\nReturn the type of a component within a Model.  Return type is a String.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.comptypes","page":"API","title":"GModelFit.comptypes","text":"comptypes(model::Model)\n\nReturn a OrderedDict{Symbol, String} with the types of all components within a Model.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.coords","page":"API","title":"GModelFit.coords","text":"coords(d::Domain{1})\ncoords(d::Domain, dim::Integer)\ncoords(d::CartesianDomain, dim::Integer)\n\nReturns coordinates of all points along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.domain","page":"API","title":"GModelFit.domain","text":"domain(d::AbstractMeasures)\n\nReturn the domain associated to an AbstractMeasures object.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.fit","page":"API","title":"GModelFit.fit","text":"fit(model::Model, data::Measures, solver=lsqfit())\n\nFit a model to an empirical data set using the specified solver (default: lsqfit()).  See also fit!.\n\n\n\n\n\nfit(multi::Vector{Model}, data::Vector{Measures{N}}, solver=lsqfit())\n\nFit a multi-model to a set of empirical data sets using the specified solver (default: lsqfit()).  See also fit!.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.fit!","page":"API","title":"GModelFit.fit!","text":"fit!(model::Model, data::Measures, solver=lsqfit())\n\nFit a model to an empirical data set using the specified solver (default: lsqfit()).  Upon return the parameter values in the Model object are set to the best fit ones.  See also fit.\n\n\n\n\n\nfit!(multi::Vector{Model}, data::Vector{Measures{N}}, solver=lsqfit())\n\nFit a multi-model to a set of empirical data sets using the specified solver (default: lsqfit()).  Upon return the parameter values in the Model objects are set to the best fit ones.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.fitstat","page":"API","title":"GModelFit.fitstat","text":"fitstat(model::Model, data::AbstractMeasures)\n\nCompare a model to a dataset and return the fit statistic.\n\n\n\n\n\nfitstat(models::Vector{Model}, data::Vector{<: AbstractMeasures})\n\nCompare a multi-model to a multi-dataset and return fit statistic.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.freeze!","page":"API","title":"GModelFit.freeze!","text":"freeze!(model::Model, cname::Symbol)\n\nFreeze a component in the model (i.e. treat all component parameters as fixed for fitting).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex","page":"API","title":"Base.getindex","text":"getindex(model::Model, cname::Symbol)\n\nReturn the model component with name cname.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.haskey","page":"API","title":"Base.haskey","text":"haskey(m::Model, name::Symbol)\n\nCheck whether a component exists in model.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.isfreezed","page":"API","title":"GModelFit.isfreezed","text":"isfreezed(model::Model, cname::Symbol)\n\nCheck whether a component is freezed in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API","title":"Base.length","text":"length(model::Model)\n\nReturn number of components in a model.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.select_maincomp!","page":"API","title":"GModelFit.select_maincomp!","text":"select_maincomp!(model::Model, cname::Symbol)\n\nForce a component to be the final one for model evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.thaw!","page":"API","title":"GModelFit.thaw!","text":"thaw!(model::Model, cname::Symbol)\n\nThaw a freezed component in the model (i.e. treat component parameters as fixed only if explicitly set in the corresponding Parameter structure).\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.uncerts","page":"API","title":"GModelFit.uncerts","text":"uncerts(d::Measures)\n\nReturns the measurement uncertainties as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.values","page":"API","title":"Base.values","text":"values(d::Measures)\n\nReturns the measurement values as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-exported-symbols","page":"API","title":"Non-exported symbols","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following symbols are not exported by the GModelFit.jl package since they are typically not used in every day work, or aimed to debugging purposes.  Still, they can be useful in some case, hence they are documented here.","category":"page"},{"location":"api/#GModelFit.Solvers.FitSummary","page":"API","title":"GModelFit.Solvers.FitSummary","text":"FitSummary\n\nA structure summarizing the results of a fitting process.\n\nFields:\n\nstart::DateTime: timestamp at the beginning of the fitting process;\nelapsed::Float64: elapsed time (in seconds);\nndata::Int: number of data empirical points;\nnfree::Int: number of free parameters;\nfitstat::Float64: fit statistics (equivalent ro reduced Ï^2 for Measures objects);\nstatus: minimization process status (tells whether convergence criterion has been satisfied, or if an error has occurred during fitting);\nsolver_retval: solver return value.\n\nNote: the solver_retval field can not be serialized, will contain nothing when deserialized.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.FunctDesc","page":"API","title":"GModelFit.FunctDesc","text":"FunctDesc\n\nA \"Julia function\" descriptor containing the reference to the function itself, a string representation of its source code definition (for displaying purposes) and the lists of its arguments.  It can be invoked using the standard syntax for functions\n\nExample:\n\njulia> f = GModelFit.FunctDesc( (x, p=0) -> x + p,   # actual function definition\n                               \"(x, p=0) -> x + p\",  # string representation\n                               [:x],                 # vector of argument namess\n                               [:(p = 0)])           # vector of `Expr` with arguments default values\njulia> f(1, 2)\n3\n\nNote that it is inconvenient to directly create a FunctDescr using its constructor, and the above results can be obtained by using the @fd macro:\n\nf = @fd (x, p=0) -> x + p\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.IdealInstrument","page":"API","title":"GModelFit.IdealInstrument","text":"IdealInstrument\n\nAn instrument response representing an ideal instrument, for which unfolded and folded models are identical.\n\nThis structure has no fields.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.ModelSnapshot","page":"API","title":"GModelFit.ModelSnapshot","text":"ModelSnapshot\n\nA structure containing a snapshot (i.e. a \"frozen\" state) of a Model.  A snapshot contains the same parameters and component evaluations of the original model, and provide the same user interface.  Moreover, a ModelSnapshot can be serialized to a file and de-serialized in another Julia session (see GModelFit.serialize()).\n\nThe best fit model and parameter values returned by the fit() function are provided as a ModelSnapshot object .\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Parameter","page":"API","title":"GModelFit.Parameter","text":"Parameter\n\nA structure representing a model parameter.\n\nFields:\n\nval::Float64: parameter value (initial guess before fitting, or best fit one after fitting);\nlow::Float64: lower limit for the value (default: -Inf);\nhigh::Float64: upper limit for the value (default: +Inf);\nfixed::Bool: whether the parameter is fixed during fitting (default: false);\npatch::Union{Nothing, Symbol, FunctDesc}: patch prescription within the same model;\nmpatch::Union{Nothing, FunctDesc}: patch prescription in a multi-model analysis;\nactual::Float64: actual value for the parameter (i.e. after applying the patch prescription)`;\nunc::Float64: 1Ï uncertainty associated to the parameter value.\n\nNote: the Parameter fields are supposed to be accessed directly by the user, without invoking any get/set method.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.dependencies","page":"API","title":"GModelFit.dependencies","text":"dependencies(comp::AbstractComponent)\n\nReturn the name of dependecies for a component. Return value must be a Vector{Symbol}.\n\nDefault implementation returns Symbol[] (i.e. no dependencies).\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.evaluate!","page":"API","title":"GModelFit.evaluate!","text":"evaluate!(comp::AbstractComponent, domain::AbstractDomain, output::Abstractvector, param1, param2....\nevaluate!(comp::AbstractComponent, domain::AbstractDomain, output::Abstractvector, deps::AbstractVector, param1, param2....\n\nEvaluate component comp on the given domain using deps dependencies and param1, param2, ... parameters.  Output should be stored in theoutput` vector.\n\nIf the component has no dependencies the deps argument should not be present.\n\nThe evaluate! function is called with the output, deps and parameter arguments containing either Float64 values (to evaluate the component) or ForwardDiff.Dual values (to evaluate the component derivatives).\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.mock","page":"API","title":"GModelFit.mock","text":"mock(::Type{Measures}, model::Model; keywords...)\nmock(::Type{Measures}, multi::Vector{Model}; keywords...)\n\nGenerate mock dataset(s) using a ground truth Model or Vector{Model} object. The first version returns a single Measures object, while the second returns a Vector{Measures}.\n\nThe measurement random errors added to the data points are drawn from a Normal distribution centered on the data value itself, and a width given by the sum of three contributions:\n\nproportional part: error proportional to each data point value;\nrange part: error proportional to the range spanned by all values in a single dataset;\nabsolute part: absolute error value.\n\nNo systematic error is considered when generating mock dataset(s).\n\nAccepted keywords:\n\nproperr=0.01: proportional error;\nrangeerr=0.05: range error;\nabserr=0.: absolute error;\nseed=nothing: seed for the Random.MersenneTwister generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.prepare!","page":"API","title":"GModelFit.prepare!","text":"prepare!(comp::AbstractComponent, domain::AbstractDomain)\n\nInvoked to precompute component-specific quantities\n\nThis method is invoked only once when the component is first evaluated hence it is the perfect place to pre-compute quantities associated to a component evaluation on a specific domain.\n\n\n\n\n\nprepare!(IR::AbstractInstrumentResponse, folded_domain::AbstractDomain)\n\nInvoked to precompute instrument response specific quantities.\n\nThis method is invoked when the instrument response is first evaluated hence it is the perfect place to pre-compute relevant quantities associated to the evaluation on a specific folded domain.\n\nExtension of this method for user defined instrument response is optional, and the default implementation nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.serialize","page":"API","title":"GModelFit.serialize","text":"GModelFit.serialize(filename::String, ::ModelSnapshot[, ::FitSummary[, ::Measures]]; compress=false)\nGModelFit.serialize(filename::String, ::Vector{ModelSnapshot}[, ::FitSummary[, ::Vector{Measures}]]; compress=false)\n\nSerialize GModelFit object(s) using a JSON format. The serializable objects are:\n\nModelSnapshot and Vector{ModelSnapshot} (mandatory argument);\nFitSummary (optional);\nMeasures and Vector{Measures} (optional);\n\nIf compress=true the resulting JSON file will be compressed using GZip. Objects can later be deserialized in a different Julia session with GModelFit.deserialize.\n\nNote: The GModelFit.serialize function also accepts Model and Vector{Model} but they will be internally converted to ModelSnapshot(s).\n\nExample:\n\n# Create GModelFit objects\nusing GModelFit\nmodel = Model(:linear => @fd (x, b=2, m=0.5) -> (b .+ x .* m))\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, stats = fit(model, data)\n\n# Serialize objects and save in a file\nGModelFit.serialize(\"my_snapshot.json\", bestfit, stats, data)\n\n# Restore objects (possibly in a different Julia session)\nusing GModelFit\n(bestfit, stats, data) = GModelFit.deserialize(\"my_snapshot.json\")\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.set_IR!","page":"API","title":"GModelFit.set_IR!","text":"set_IR!(model::Model, IR::AbstractInstrumentResponse)\n\nSet a model to use the instrument response passed as argument.\n\nIf this method is not invoked the GModelFit.IdealInstrument response will be used.\n\n\n\n\n\n","category":"function"},{"location":"#GModelFit.jl","page":"Home","title":"GModelFit.jl","text":"","category":"section"},{"location":"#A-model-fitting-framework-for-Julia.","page":"Home","title":"A model fitting framework for Julia.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stars)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GModelFit.jl is a general purpose, data-driven model fitting framework for Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides the basic tools to define, interactively manipulate and efficiently evaluate a (possibly very complex) model, and to fit the latter to empirical data. The main functionalities are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"it handles datasets of any dimensionality;\nthe syntax is very simple and concise as it resembles the indexing for dictionaries and the field access for structs.  The most relevant functions are the self-explanatory fit() and the object constructors (see Main functionalities);\nthe fitting model is evaluated on a user defined domain, and is the result of a combination of model components or mathematical expressions (in the form of lambda functions), or any arbitrary mixture of the two;\nit provides several ready-to-use Built-in components, and it also allows to define new components to suit specific needs (Custom components);\nall components results are cached so that repeated evaluations with the same parameter values do not involve further calculations (memoization);\nmodel parameters can be fixed to a specific value, limited in an interval, and/or be dynamically linked (patched) to the values of other parameters (see Parameter constraints);\nmultiple data sets can be fitted simultaneously against different models whose parameters can be patched (see Multi-dataset fitting);\nit supports specifying an Instrument response to convert model evalutions into a form suitable to be compared to empirical data;\nit supports different solvers (LsqFit, CMPFit and NonlinearSolve), all aimed to carry out non-linear least squares minimization (see Solvers);\nit supports forward mode automatic differentiation (AD) of models via ForwardDiff;\nit provides facilities for interactive fitting and quick plotting (see Quick plot (1D)).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The fitting process involves the automatic variation of the parameter values, subject to the user defined constraints, until the differences between the evaluated model and the empirical data are minimized. The implementation details depends on the chosen solver.  The purpose of GModelFit.jl is thus to act as an interface between the high-level model definition and manipulation (facing the user), and the low-level implementation details (facing the solver).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add GModelFit","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ] character starts the Julia package manager. Hit backspace key to return to Julia prompt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to easily visualize the outcomes of 1D analysis you may be interested in installing also Gnuplot.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add Gnuplot","category":"page"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The typical workflow to use GModelFit.jl is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Wrap empirical data domain and measures into one (ore more) Domain and Measures object(s);\nCreate a Model object  by providing components or mathematical expressions, each representing a specific aspect of the theoretical model;\nOptionally set initial guess parameter values and/or constraints between model parameters;\nFit the model against the data and inspect the results;\nIf needed, modify the model and repeat the fitting process;\nExploit the results and outputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A very simple example showing the above workflow is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GModelFit\n\n# Prepare vectors with domain points, empirical measures and associated\n# uncertainties\nx    = [0.1, 1.1, 2.1, 3.1, 4.1]\nmeas = [6.29, 7.27, 10.41, 18.67, 25.3]\nunc  = [1.1, 1.1, 1.1, 1.2, 1.2]\n\n# Prepare Domain and Measures objects\ndom  = Domain(x)\ndata = Measures(dom, meas, unc)\n\n# Create a model using an explicit mathematical expression, and provide the\n# initial guess values:\nmodel = Model(@fd (x, a2=1, a1=1, a0=5) -> (a2 .* x.^2  .+  a1 .* x  .+  a0))\n\n# Fit model to the data\nbestfit, fsumm = fit(model, data)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The GModelFit.jl package implements a show method for many of the data types involved, hence the above code results in the following output:","category":"page"},{"location":"","page":"Home","title":"Home","text":"show((bestfit, fsumm)) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing the best fit parameter values and the associated uncertaintites, as well as a few summarizing concerning the fitting process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If not saitisfied with the result you may, for instance, change the initial value for a parameter and re-run the fit:","category":"page"},{"location":"","page":"Home","title":"Home","text":"model[:main].a0.val = 5\nbestfit, fsumm = fit(model, data)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once done, you may plot the data and the best fit model with a plotting framework of your choice. E.g., with Gnuplot.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Gnuplot\n@gp coords(dom) values(data) uncerts(data) \"w yerr t 'Data'\" :-\n@gp :- coords(dom) bestfit() \"w l t 'Best fit model'\"\nsaveas(\"simple_example\"); # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, you can easily access the numerical results for further analysis, e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"println(\"Best fit value for the offset parameter: \", \n\tbestfit[:main].a0.val, \" Â± \", \n\tbestfit[:main].a0.unc, \"\\n\",\n\t\"Reduced Ï^2: \", fsumm.fitstat)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above example is definitely a simple one, but more complex ones follow essentially the same workflow.","category":"page"},{"location":"mainfunctions/#Main-functionalities","page":"Main functionalities","title":"Main functionalities","text":"","category":"section"},{"location":"mainfunctions/","page":"Main functionalities","title":"Main functionalities","text":"Preparation of empirical data: both the data domain and empirical values (with associated uncertainties) should be wrapped into Domain (or CartesianDomain) and Measures objects respectively.  Such objects are created by simply passing AbstractVector{<: Real} to their respective constructors, e.g.:\nusing GModelFit\ndom  = Domain([0.1, 1.1, 2.1, 3.1, 4.1])\ndata = Measures(dom, [6.29, 7.27, 10.41, 18.67, 25.3],\n                      [1.1,  1.1,   1.1,   1.2, 1.2])\nprintln() # hide\nComponent creation: a component is a structure inheriting GModelFit.AbstractComponent and hosting one or more fields with type GModelFit.Parameter.  It is created by simply invoking its constructor, e.g.:\nusing GModelFit\n\n# Create a stand-alone component (i.e. a component used outisde a model)\ncomp = GModelFit.Gaussian(1, 0, 1) # numbers represent the parameter values\n\n# A stand-alone component can be evaluated on a user provided domain as follows:\ncomp(Domain(-4:0.1:4))\n\n# Evaluate the component providing custom parameter values:\ncomp(Domain(-4:0.1:4), center=0.1, sigma=1.3)\nprintln() # hide\nThe list of available components is available in Built-in components.\nNote: a component with dependencies can't be evaluated as a stand-alone since it requires the corresponding dependencies to be available in a model.","category":"page"},{"location":"mainfunctions/","page":"Main functionalities","title":"Main functionalities","text":"Model definition and manipulation: a Model object is essentially a dictionary of components with Symbol keys.  The keys(), haskey() and iterate() methods defined for the Model object provide the usual functionalities as for any dictionary.  A model object can be created and manipulated as follows:\nusing GModelFit\n\n# Create an empty model\nmodel = Model()\n\n# Add two Gaussian components, and a third one representing their sum\nmodel[:comp1] = GModelFit.Gaussian(1, 3, 1)\nmodel[:comp2] = GModelFit.Gaussian(0.5, 4, 0.3)\nmodel[:sum] = @fd (comp1, comp2) -> comp1 .+ comp2\n\n# Modify a parameter value:\nmodel[:comp1].center.val = 5\n\n# Evaluate the model on a user defined domain\ndom = Domain(0:0.1:10)\nmodel(dom)\n\n# Evaluate the model, but retrieve the outcome of the :comp2 component\nmodel(dom, :comp2)\nprintln() # hide\nMock data: the GModelFit.mock() function allows to generate mock data set(s) using a (multi-)model as ground truth, and add a random noise to simulate the measurement process.  An example using the previously defined model and domain is as follows:\ndata = GModelFit.mock(Measures, model, dom)\nprintln() # hide\nThis functionality is used in the examples of the next sections to generate the mock datasets.\nFitting: the main functions to fit a model (represented by a Model object) to an empirical dataset (represented by a Measures object) are fit and fit!.  The latter provide the same functionality as the former with the only difference that upon return the Model object will have their parameters set to the best fit values.  In both cases the Model object will be evaluated on the same domain associated with the Measures object.  An overview of the fit workflow is as follows:\n(Image: )\nThe following code shows how to fit the previously generated mock data set to the above model:\nbestfit, fsumm = fit(model, data)\nThe fit function returns a tuple with:\na GModelFit.ModelSnapshot structure containing a snapshot of the best fit model;\na GModelFit.FitSummary structure summarizing the fit result.\nTo perform a Multi-dataset fitting simply pass a Vector{Model} and a Vector{Measures} to the fit function.\nSerialization: a few structures (such as  GModelFit.ModelSnapshot, GModelFit.FitSummary and Measures{N}) can be serialized, i.e. stored in a file, and later de-serialized in a separata Julia session.  This is useful when the best fit model and associated informations must be saved for a later use, without the need to re-run the fitting.  The best fit model, fit statistics and mock dataset used above can be serialized with:\nGModelFit.serialize(\"my_snapshot.json\", bestfit, fsumm, data)\nprintln() # hide\nIn a separate Julia session, you can obtain a copy of exactly the same data with\nusing GModelFit\n(bestit, fsumm, data) = GModelFit.deserialize(\"my_snapshot.json\")\nprintln() # hide","category":"page"}]
}
