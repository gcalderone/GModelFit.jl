var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Exported-symbols","page":"API","title":"Exported symbols","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The list of GModelFit.jl exported symbols is as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"CartesianDomain{N}\nDomain{N}\nMeasures{N}\nModel\n@fd\naxis\ncompare\ncomptype\ncoords\ndomain\nfit\nfit!\nfreeze!\ngetindex\nhaskey\nisfreezed\nselect_maincomp!\nthaw!\nuncerts\nvalues","category":"page"},{"location":"api/#GModelFit.CartesianDomain","page":"API","title":"GModelFit.CartesianDomain","text":"CartesianDomain{N}\n\nAn object representing a model, or a dataset, N-dimensional cartesian domain (i.e. a grid).\n\nAvailable constructors:\n\nDomain(axis...): each argument is a vector containing the coordinates on a given axis (arguments may have different lengths);\nDomain(lengths...): returns a N-dim CartesianDomain object whose axis lengths are specified in the arguments.\n\nNote that a CartesianDomain requires at least 2 dimensions.\n\nCoordinates for all points along a given axis can be obtained with the coords() function, while the coordinates of the grid can be obtained with axis().\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Domain","page":"API","title":"GModelFit.Domain","text":"Domain{N}\n\nAn object representing a model, or a dataset, N-dimensional linear domain.\n\nAvailable constructors:\n\nDomain(coords...): each argument is a vector, one for each dimension (all arguments must have same lengths);\nDomain(length): returns a 1-dim Domain object of the given length.\n\nCoordinates for all points along a given axis can be obtained with the coords function.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Measures","page":"API","title":"GModelFit.Measures","text":"Measures{N}\n\nAn object representing a set of empirical measurements (with Gaussian uncertainties) as measured on a specific domain.\n\nAvailable constructors:\n\nMeasures(domain::Domain{N},           values::AbstractVector{T},           uncerts::AbstractVector{T}) where {T <: AbstractFloat, N}\nMeasures(domain::CartesianDomain{N},           values::AbstractArray{T, N},           uncerts::AbstractArray{T, N}) where {T <: AbstractFloat, N}\nMeasures(values::AbstractVector, uncerts)\n\nIn the above constructor methods the last argument may also be a scalar value, to set the same uncertainty for all the measurements. The method accepting a CartesianDomain requires arrays with at least 2 dimensions.  In the last constructor the Domain object is automatically built depending on the length of the values vector.\n\nThe domain, values and uncertainties for a Measures object can be retrieved using the domain, values and uncerts functions respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Model","page":"API","title":"GModelFit.Model","text":"Model\n\nA structure containing a model description, whose evaluation is suitable to be compared to a single empirical dataset.\n\nConstructor is: Model(domain::AbstractDomain, components...) where the first argument is either a Domain or CartesianDomain object, and the remaining one(s) is (are) the model component(s), which may be given as:\n\na single Dict{Symbol, AbstractComponent}, where the keys are the names and the values the component objects;\na single component, which will have a default name is assigned (:main);\na single FunctDesc, which will be wrapped into an LComp component and a default name will be assigned (:main);\none or more Pair{Symbol, AbstractComponent}, where the first element is the name and the second is the component.\n\nYou may access the individual component in a Model using the indexing syntax, as if it was a Dict{Symbol, AbstractComponent}.  Also, you may add new components to a Model after it has been created using the same synatx.  Finally, you may use the keys() and haskey() functions with their usual meanings.\n\nIndividual components may be freezed (i.e. have all its parameters fixed during fitting, despite the individual Parameter settings) or thawed using the freeze!() and thaw!() functions.  Use the isfreezed() function to check if a component is freezed.\n\nThe main component, i.e. the one whose evaluation corresponds to the overall model evaluation, is typically automatically identified by analyzing the component dependencies.  However a specific component may be forced to be the main one by invoking select_maincomp!.\n\nThe most important function for a Model object is fit(), which allows to fit the model against an empirical dataset. The ! in the name reminds us that, after fitting, the parameter values will be set to the best fit ones (rather than retaining their original values).\n\nThe model and all component evaluation can be obtained by using the Model object has if it was a function: with no arguments it will return the main component evaluation, while if a Symbol is given as argument it will return the evaluation of the component with the same name.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.@fd","page":"API","title":"GModelFit.@fd","text":"@fd expr\n\nMacro to generate a FunctDesc object using the same syntax as for a standard Julia anonymous function.\n\nExample\n\njulia> f = @fd (x, p=0) -> x + p\n\njulia> f(1, 2)\n3\n\n\n\n\n\n","category":"macro"},{"location":"api/#GModelFit.axis","page":"API","title":"GModelFit.axis","text":"axis(d::CartesianDomain, dim::Integer)\n\nReturns the coordinates of the grid along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.compare","page":"API","title":"GModelFit.compare","text":"compare(model::Model, data::Measures)\n\nCompare a model to a dataset and return a FitStats object.\n\n\n\n\n\ncompare(multi::Vector{Model}, data::Vector{Measures{N}})\n\nCompare a multi-model to a multi-dataset and return a FitStats object.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.comptype","page":"API","title":"GModelFit.comptype","text":"comptype(model::Model, cname::Symbol)\n\nReturn a component type as a string.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.coords","page":"API","title":"GModelFit.coords","text":"coords(d::Domain{1})\ncoords(d::Domain, dim::Integer)\ncoords(d::CartesianDomain, dim::Integer)\n\nReturns coordinates of all points along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.domain","page":"API","title":"GModelFit.domain","text":"domain(d::AbstractMeasures)\n\nReturn the domain associated to an AbstractMeasures object.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.fit","page":"API","title":"GModelFit.fit","text":"fit(model::Model, data::Measures; minimizer::AbstractMinimizer=lsqfit())\n\nFit a model to an empirical data set using the specified minimizer (default: lsqfit()).\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.fit!","page":"API","title":"GModelFit.fit!","text":"fit!(model::Model, data::Measures; minimizer::AbstractMinimizer=lsqfit())\n\nFit a model to an empirical data set using the specified minimizer (default: lsqfit()).  Upon return the parameter values in the Model object are set to the best fit ones.\n\n\n\n\n\nfit(multi::Vector{Model}, data::Vector{Measures{N}}; minimizer::AbstractMinimizer=lsqfit())\n\nFit a multi-model to a set of empirical data sets using the specified minimizer (default: lsqfit()).\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.freeze!","page":"API","title":"GModelFit.freeze!","text":"freeze!(model::Model, cname::Symbol)\n\nFreeze a component in the model (i.e. treat all component parameters as fixed for fitting).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex","page":"API","title":"Base.getindex","text":"getindex(model::Model, cname::Symbol)\n\nReturn the model component with name cname.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.haskey","page":"API","title":"Base.haskey","text":"haskey(m::Model, name::Symbol)\n\nCheck whether a component exists in model.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.isfreezed","page":"API","title":"GModelFit.isfreezed","text":"isfreezed(model::Model, cname::Symbol)\n\nCheck whether a component is freezed in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.select_maincomp!","page":"API","title":"GModelFit.select_maincomp!","text":"select_maincomp!(model::Model, cname::Symbol)\n\nForce a component to be the final one for model evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.thaw!","page":"API","title":"GModelFit.thaw!","text":"thaw!(model::Model, cname::Symbol)\n\nThaw a freezed component in the model (i.e. treat component parameters as fixed only if explicitly set in the corresponding Parameter structure).\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.uncerts","page":"API","title":"GModelFit.uncerts","text":"uncerts(d::Measures)\n\nReturns the measurement uncertainties as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.values","page":"API","title":"Base.values","text":"values(d::Measures)\n\nReturns the measurement values as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-exported-symbols","page":"API","title":"Non-exported symbols","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following symbols are not exported by the GModelFit.jl package since they are typically not used in every day work, or aimed to debugging purposes.  Still, they can be useful in some case, hence they are documented here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"GModelFit.evalcounter\nGModelFit.evalcounters\nGModelFit.CompEval\nGModelFit.FitStats\nGModelFit.FunctDesc\nGModelFit.ModelEval\nGModelFit.ModelSnapshot\nGModelFit.Parameter\nGModelFit.comptypes\nGModelFit.dependencies\nGModelFit.evaluate!\nGModelFit.mock\nGModelFit.prepare!\nGModelFit.serialize\nGModelFit.update!","category":"page"},{"location":"api/#GModelFit.evalcounter","page":"API","title":"GModelFit.evalcounter","text":"evalcounter(meval::ModelEval, cname::Symbol)\n\nReturn the number of times a component has been evaluated.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.evalcounters","page":"API","title":"GModelFit.evalcounters","text":"evalcounters(meval::ModelEval)\n\nReturn a OrderedDict{Symbol, Int} with the number of times each model component has been evaluated.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.CompEval","page":"API","title":"GModelFit.CompEval","text":"CompEval(comp::AbstractComponent, domain::AbstractDomain)\n\nA container for a component to be evaluated on a specific domain.\n\nFields:\n\ncomp::AbstractComponent: the wrapped component;\ndomain::AbstractDomain: the domain where the component is supposed to be evaluated;\ncounter::Int: the number of times the component has been evaluated since creatio of the CompEval object;\nlastparvalues::Vector{Float64}: the parameter values used in the last evaluation.  A call to update!() with the same values stored in lastparvalues will not result in a new evaluation;\ndeps::Vector{Vector{Float64}}: the evaluation buffers of all dependencies;\nbuffer::Vector{Float64}: the buffer to store the outcome of the component.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.FitStats","page":"API","title":"GModelFit.FitStats","text":"FitStats\n\nA structure representing the results of a fitting process.\n\nFields:\n\ntimestamp::DateTime: time at which the fitting process has started;\nelapsed::Float64: elapsed time (in seconds);\nndata::Int: number of data empirical points;\nnfree::Int: number of free parameters;\ndof::Int: ndata - nfree;\nfitstat::Float64: fit statistics (equivalent ro reduced χ^2 for Measures objects);\nstatus: minimizer exit status (tells whether convergence criterion has been satisfied, or if an error has occurred during fitting);\n\nNote: the FitStats fields are supposed to be accessed directly by the user, without invoking any get() method.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.FunctDesc","page":"API","title":"GModelFit.FunctDesc","text":"FunctDesc\n\nA \"Julia function\" descriptor containing the reference to the function itself, a string representation of its source code definition (for displaying purposes) and the lists of its arguments.  It can be invoked using the standard syntax for functions\n\nExample:\n\njulia> f = GModelFit.FunctDesc( (x, p=0) -> x + p,   # actual function definition\n                               \"(x, p=0) -> x + p\",  # string representation\n                               [:x],                 # vector of argument namess\n                               [:(p = 0)])           # vector of `Expr` with arguments default values\njulia> f(1, 2)\n3\n\nNote that it is inconvenient to directly create a FunctDescr using its constructor, and the above results can be obtained by using the @fd macro:\n\nf = @fd (x, p=0) -> x + p\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.ModelEval","page":"API","title":"GModelFit.ModelEval","text":"ModelEval(model::Model, domain::AbstractDomain)\n\nA structure containing the required informations to evaluate a model on a specific domain, and to compare the outcomes to a single empirical dataset.\n\nThe model and all component evaluation can be obtained by using the Model object has if it was a function: with no arguments it will return the main component evaluation, while if a Symbol is given as argument it will return the evaluation of the component with the same name.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.ModelSnapshot","page":"API","title":"GModelFit.ModelSnapshot","text":"ModelSnapshot\n\nA structure containing a snapshot (i.e. a \"frozen\" state) of a Model.  A snapshot contains the same parameters and component evaluations of the original model, and provide the same user interface.  Moreover, a ModelSnapshot can be serialized to a file and de-serialized in another Julia session (see GModelFit.serialize()).\n\nThe best fit model and best fit parameter values returned as a ModelSnapshot object by the fit() function.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.Parameter","page":"API","title":"GModelFit.Parameter","text":"Parameter\n\nA structure representing a model parameter.\n\nFields:\n\nval::Float64: parameter value (initial guess before fitting, or best fit one after fitting);\nlow::Float64: lower limit for the value (default: -Inf);\nhigh::Float64: upper limit for the value (default: +Inf);\nfixed::Bool: whether the parameter is fixed during fitting (default: false);\npatch::Union{Nothing, Symbol, FunctDesc}: patch prescription within the same model;\nmpatch::Union{Nothing, FunctDesc}: patch prescription in a multi-model analysis;\nactual::Float64: actual value for the parameter (i.e. after applying the patch prescription)`;\nunc::Float64: 1σ uncertainty associated to the parameter value.\n\nNote: the Parameter fields are supposed to be accessed directly by the user, without invoking any get/set method.\n\n\n\n\n\n","category":"type"},{"location":"api/#GModelFit.comptypes","page":"API","title":"GModelFit.comptypes","text":"comptypes(model::Model)\n\nReturn a OrderedDict{Symbol, String} with the model component types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.dependencies","page":"API","title":"GModelFit.dependencies","text":"dependencies(comp::AbstractComponent)\n\nReturn the name of dependecies for a component. Return value must be a Vector{Symbol}.\n\nDefault implementation returns Symbol[] (i.e. no dependencies.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.evaluate!","page":"API","title":"GModelFit.evaluate!","text":"evaluate!(ceval::CompEval, pvalues::Vector{Float64})\n\nEvaluate a component using the provided parameter values.  Outcomes shall be stored in the CompEval.buffer vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.mock","page":"API","title":"GModelFit.mock","text":"mock(::Type{Measures}, model::Model; keywords...)\nmock(::Type{Measures}, multi::Vector{Model}; keywords...)\n\nGenerate mock dataset(s) using a ground truth Model or Vector{Model} object. The first version returns a single Measures object, while the second returns a Vector{Measures}.\n\nThe measurement random errors added to the data points are drawn from a Normal distribution centered on the data value itself, and a width given by the sum of three contributions:\n\nproportional part: error proportional to each data point value;\nrange part: error proportional to the range spanned by all values in a single dataset;\nabsolute part: absolute error value.\n\nNo systematic error is considered when generating mock dataset(s).\n\nAccepted keywords:\n\nproperr=0.01: proportional error;\nrangeerr=0.05: range error;\nabserr=0.: absolute error;\nseed=nothing: seed for the Random.MersenneTwister generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.prepare!","page":"API","title":"GModelFit.prepare!","text":"prepare!(comp::AbstractComponent, domain::AbstractDomain)\n\nAllocate the buffer for a component evaluation on a specific domain.  Return value must be a Vector{Float64}.\n\nThis function is invoked only once when the ModelEval structure is created (typically within a fit of fit! call), hence it is the perfect place to pre-compute quantities associated to a component evaluation on a specific domain.  Default implementation returns a vector filled with NaNs with the same length as the domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.serialize","page":"API","title":"GModelFit.serialize","text":"GModelFit.serialize(filename::String, ::ModelSnapshot[, ::FitStats[, ::Measures]]; compress=false)\nGModelFit.serialize(filename::String, ::Vector{ModelSnapshot}[, ::FitStats[, ::Vector{Measures}]]; compress=false)\n\nSerialize GModelFit object(s) using a JSON format. The serializable objects are:\n\nModelSnapshot and Vector{ModelSnapshot} (mandatory argument);\nFitStats (optional);\nMeasures and Vector{Measures} (optional);\n\nIf compress=true the resulting JSON file will be compressed using GZip. Objects can later be deserialized in a different Julia session with GModelFit.deserialize.\n\nNote: The GModelFit.serialize function also accepts Model and Vector{Model} but they will be internally converted to ModelSnapshot(s).\n\nExample:\n\n# Create GModelFit objects\nusing GModelFit\nmodel = Model(:linear => @fd (x, b=2, m=0.5) -> (b .+ x .* m))\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, stats = fit(model, data)\n\n# Serialize objects and save in a file\nGModelFit.serialize(\"my_snapshot.json\", bestfit, stats, data)\n\n# Restore objects (possibly in a different Julia session)\nusing GModelFit\n(bestit, stats, data) = GModelFit.deserialize(\"my_snapshot.json\")\n\n\n\n\n\n","category":"function"},{"location":"api/#GModelFit.update!","page":"API","title":"GModelFit.update!","text":"update!(ceval::CompEval, pvalues::Vector{Float64})\n\nUpdate a CompEval structure using the provided parameter values.\n\nThe component is actually evaluated if one of the following applies:\n\nthe component has never been evaluated;\nthe component has at least one dependency (whose evaluation may have changed since its last evaluation);\nat least one parameter value has changed since last evaluation.\n\nIf none of the above applies, no evaluation occurs.\n\n\n\n\n\nupdate!(meval::ModelEval)\n\nUpdate a ModelEval structure by evaluating all components in the model.\n\n\n\n\n\n","category":"function"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"include(\"setup.jl\")","category":"page"},{"location":"concepts/#Data-types-and-functionalities","page":"Data types and functionalities","title":"Data types and functionalities","text":"","category":"section"},{"location":"concepts/#Basic-concepts-and-data-types","page":"Data types and functionalities","title":"Basic concepts and data types","text":"","category":"section"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"In order to exploit the GModelFit.jl model expressiveness a few concepts need to be introduced, along with their associated data types:","category":"page"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"Domain: an N-dimensional grid of points associated to empirical measures, and used to evaluate a model.  It is analogous to the independent varible vecx in the f(vecx) notation. It is represented by either:\na Domain{N} object for linear domains, where the coordinates for each of the N dimensions are explicitly specified for all the points;\nor a CartesianDomain{N} object where the coordinates are specified for each of the N axis and the coordinates for all points are obtained as the cartesian product of all the axes.  A cartesian domain is internally transformed into a linear one when needed;\nA domain object (either linear or cartesian) is required as first argument for the Measures constructor (see below).\nMeasures: a container for the N-dimensional empirical data and their associated 1sigma Gaussian uncertainties, represented by an object of type Measures{N} (further options may be available in the future, such as Poisson counts);\nModel component: the atomic building block of a (potentially complex) model, it is essentially a function used to map a Domain or CartesianDomain object into a Vector{Float64} representing the component evaluation.  A component is a structure inheriting from GModelFit.AbstractComponent and is typically characterized by one or more parameters (see below).   The GModelFit.jl package provides several Built-in components, and new ones can be implemented by the user (see Custom components).  The memoization mechanism operates at the component level and aims to avoid unnecessary re-evaluation of the component if none of its parameter values has changed since last evaluation;\nParameter: a single floating point number characterizing a specific aspect for the evaluation of a component (e.g. the slope of a power law or the width of a Gaussian profile). The parameter values are automatically varied during the fitting process until the residuals between the global model evaluation and the empirical data are minimized.  A parameter can be fixed to a specific value, limited in an interval, and/or be dynamically calculated (patched) according to the values of other parameters.  All parameters are represented by an object of type GModelFit.Parameter;\nModel: is the overall model description, whose evaluation is supposed to be compared to a single Measures object and whose parameters are varied during fitting to reduce the residuals.  Internally, a model is implemented as a dictionary containing one or more components, each identified by a unique Symbol name (see Model);\nComponent dependencies and main component: the evaluation of a component, say A, may use the outcome of another component, say B, to calculate its output, thus inducing a dependency between the two. In this case we say that A depends on B, and therefore B needs to be evaluated before A (circular dependencies are not allowed, and would raise an error if attempted).  The dependencies are automatically identified, and the last component being evaluated is dubbed main component since its output represent the overall model evaluation;\nMulti-model: a Vector{Model} containing two or more models, suitable to be compared to a corresponding Vector{Measures} to perform Multi-dataset fitting;\nMinimizer: the GModelFit.jl package provides just the tools to define and manipulate a model, but the actual fitting (namely, the minimization of the residuals) is performed by an external minimizer library.  Two minimizers are currently available:\nLsqFit: a pure-Julia minimizer;\nCMPFit: a C minimizer wrapped in a Julia package.\nBoth are automatically installed with GModelFit.jl, and LsqFit is the default choice (unless otherwise specified in the fit() function call).\nModel snapshot: the best fit model, as well as the best fit parameter values and associated uncertainties, are returned by the fit() function as a GModelFit.ModelSnapshot structure, namely a frozen snapshot of the evaluation of a Model object on a given Domain.  Components, parameters and evaluations outcomes are accessed in exactly the same way on both Model and ModelSnapshot objects, the only difference being that the latter can't be re-evaluated on different domains or parameter values.\nFit statistics: the purpose of fitting is to minimize the distance between the model and the data, as quantified by a proper fit statistic (typically a reduced chi^2 for the Gaussian uncertainties case). Such statistic, as well as other information concerning the fit, are returned by the fit() function in a GModelFit.FitStats structure;\nfunction descriptor: GModelFit.jl uses standard Julia function in two different contexts:\nto calculate the value of a Parameter as a function of other Parameter's values. In this case the parameters are said to be patched, or linked, since there is a constraint between their values.  Two (or more) parameters may be patched within the same model, or across models when performing Multi-dataset fitting;\nto define a model component using a standard Julia mathematical expression involving Parameters values or other components;\nTo use a standard function in this fashion it should be wrapped into a GModelFit.FunctDesc object which allows both to invoke the function itself, as well as to provide a string representation for display purposes.  In order to create a function descriptor object it typically is much easier to invoke the @fd macro rather than the FunctDesc constructor.","category":"page"},{"location":"concepts/#Main-functions","page":"Data types and functionalities","title":"Main functions","text":"","category":"section"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"Preparation of empirical data: both the data domain and empirical values (with associated uncertainties) should be wrapped into Domain (or CartesianDomain) and Measures objects respectively.  Such objects are created by simply passing AbstractVector{<: Real} to their respective constructors, e.g.:","category":"page"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"using GModelFit\ndom  = Domain([0.1, 1.1, 2.1, 3.1, 4.1])\ndata = Measures(dom, [6.29, 7.27, 10.41, 18.67, 25.3],\n                      [1.1,  1.1,   1.1,   1.2, 1.2])\nprintln() # hide","category":"page"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"Model definition and manipulation: a Model object is essentially a dictionary of components with Symbol keys.  The keys(), haskey() and iterate() methods defined for the Model object provide the usual functionalities as for any dictionary.  Each entry in the dictionary is a component, namely a structure inheriting GModelFit.AbstractComponent and hosting one or more fields with type GModelFit.Parameter.  A model object can be manipulated as follows:","category":"page"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"using GModelFit\n\n# Create an empty model\nmodel = Model()\n\n# Add a component\nmodel[:comp1] = GModelFit.Gaussian(1, 0, 1)  # numbers represent the guess values\n\n# Modify a parameter value:\nmodel[:comp1].center.val = 5\n\n# Evaluate the model on a user define domain\nmodel(Domain(0:0.1:10))\nprintln() # hide","category":"page"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"Fitting: the main functions to fit a model (represented by a Model object) to an empirical dataset (represented by a Measures object) are fit and fit!.  The latter provide the same functionality as the former with the only difference that upon return the Model object will have their parameters set to the best fit values.  In both cases the Model object will be evaluated on the same domain associated with the Measures object.  An overview of the fit workflow is as follows:\n(Image: )\nTo perform a Multi-dataset fitting simply pass a Vector{Model} and a Vector{Measures to the fit or fit! function.\nMock data: testing the capabilities of a model to in identifying the best fit parameters may be useful even before actual data are available.  To this purpose, the GModelFit.mock() function provides the possibility to generate mock data set(s) using a (multi-)model as ground truth, and add a random noise to simulate the measurement process.  This functionality is used in some of the examples presented in the next sections.\nSerialization: a few structures (such as  GModelFit.ModelSnapshot, GModelFit.FitStats and Measures{N}) can be serialized, i.e. stored in a file, and later de-serialized in a separata Julia session.  This is useful when the best fit model and associated informations must be saved for a later use, without the need to re-run the fitting.","category":"page"},{"location":"concepts/#GModelFit-internals","page":"Data types and functionalities","title":"GModelFit internals","text":"","category":"section"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"This section deals with GModelFit.jl internals, feel free to skip if not interested.","category":"page"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"During fitting a number of data structures are created to avoid reallocating heap memory at each minimizer iteration.  The most important of such structures are:","category":"page"},{"location":"concepts/","page":"Data types and functionalities","title":"Data types and functionalities","text":"GModelFit.CompEval: a container for a component evaluation on a specific domain.  This structure is relevant when defining Custom components as it is used to dispatch component evaluation to the proper evaluate! method;\nGModelFit.ModelEval: a container for a Model evaluation on a specific domain. This structure contains a CompEval structure for each component in a model and is updated at each iteration of the minimizer to reflect the current state;\nGModelFit.FitProblem: container for a ModelEval object, a Measures object, and a Vector{Float64} to store the normalized residuals of the comparison between the model and the data.  The GModelFit.MultiFitProblem has the same purpose in a Multi-dataset fitting case.","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"include(\"setup.jl\")","category":"page"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Generate-mock-datasets","page":"Miscellaneous","title":"Generate mock datasets","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"In some case it is useful to test a model for robustness before the emprical data are available for fitting.  This can be achieved via the GModelFit.mock() function, whose purpose is to generate a mock dataset which simulates a measurement process by adding random noise to the foreseen ground-truth.","category":"page"},{"location":"misc/#Example","page":"Miscellaneous","title":"Example","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\n\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\n\n# Generate a mock dataset on a specific domain\ndom = Domain(1:0.1:50)\ndata = GModelFit.mock(Measures, model, dom, seed=1)\n\n# Fit model against the mock dataset\nbestfit, stats = fit(model, data)","category":"page"},{"location":"misc/#Serialization","page":"Miscellaneous","title":"Serialization","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"A few structures, namely GModelFit.ModelSnapshot, GModelFit.FitStats and Measures{N}, as well as Vector(s) of such structures can be serialized, i.e. stored in a file using a dedicated JSON format.  The structures can lated be de-serialized in a separata Julia session without the need to re-run the fitting process used to create them in the first place.","category":"page"},{"location":"misc/#Example-2","page":"Miscellaneous","title":"Example","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"In the following we will generate a few GModelFit.jl objects and serialized them in a file.","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\n\ndom = Domain(1:0.1:50)\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\ndata = GModelFit.mock(Measures, model, dom, seed=1)\nbestfit, stats = fit(model, data)\n\n# Serialize objects and save in a file\nGModelFit.serialize(\"save_for_future_use.json\", bestfit, stats, data)\nprintln(); # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"The same objects can be de-serialized in a different Julia session:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\nbestfit, stats, data = GModelFit.deserialize(\"save_for_future_use.json\")","category":"page"},{"location":"misc/#Quick-plot-(1D)","page":"Miscellaneous","title":"Quick plot (1D)","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"The GModelFit.jl package implements Gnuplot.jl recipes to display plots of Measures{1} and ModelSnapshot objects., e.g.:","category":"page"},{"location":"misc/#Example-3","page":"Miscellaneous","title":"Example","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Create a model, a mock dataset and run a fit:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using GModelFit\n\ndom = Domain(0:0.01:5)\nmodel = Model(:bkg => GModelFit.OffsetSlope(1, 1, 0.1),\n              :l1 => GModelFit.Gaussian(1, 2, 0.2),\n              :l2 => GModelFit.Gaussian(1, 3, 0.4),\n              :main => SumReducer(:bkg, :l1, :l2))\ndata = GModelFit.mock(Measures, model, dom)\nbestfit, stats = fit(model, data)\nprintln(); # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"A plot of the dataset and of the best fit model can be simply obtained with","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using Gnuplot\n@gp data bestfit\nsaveas(\"gnuplot1\") # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"(Image: )","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"You may also specify axis range, labels, title, etc. using the standard Gnuplot.jl keyword syntax, e.g.:","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"using Gnuplot\n@gp xr=[1, 4.5] xlabel=\"Wavelength\" ylab=\"Flux\" \"set key outside\" data bestfit\nsaveas(\"gnuplot2\") # hide","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"(Image: )","category":"page"},{"location":"examples/#Examples:","page":"-","title":"Examples:","text":"","category":"section"},{"location":"examples/#1D:-offset-two-Gaussian-profiles","page":"-","title":"1D: offset + two Gaussian profiles","text":"","category":"section"},{"location":"examples/","page":"-","title":"-","text":"x = Domain(1:0.05:10)\nmodel = Model(x,\n    :offset => 4,\n    :line1  => GModelFit.Gaussian(1.1 , 4.4, 0.51),\n    :line2  => GModelFit.Gaussian(0.52, 5.5, 1.2 ))\n\nusing Random\nrng = MersenneTwister(0);\nnoise = maximum(model()) * 0.01\ndata = Measures(model() + noise * randn(rng, length(model())), noise);\nret1 = fit(model, data)","category":"page"},{"location":"examples/","page":"-","title":"-","text":"To produce the plots I will use the Gnuplot.jl package, but the user can choose any other package:","category":"page"},{"location":"examples/","page":"-","title":"-","text":"using Gnuplot\n@gp    \"set multi layout 2,1\" :-\n@gp :- domain(model) data.val data.unc \"w yerr tit 'Data'\" :-\n@gp :- domain(model) model(:line1) .+ model(:offset) \"w l tit 'offset + line1'\" :-\n@gp :- domain(model) model(:line2) .+ model(:offset) \"w l tit 'offset + line2'\" :-\n@gp :- domain(model) model() \"w lines tit 'Model' lw 3\" :-\n@gp :- 2 x[1] (data.val - model()) ./ data.unc fill(1., length(data)) \"w yerr tit 'Residuals'\"","category":"page"},{"location":"examples/#2D:-tilted-plane-2D-Gaussian-profile","page":"-","title":"2D: tilted plane + 2D Gaussian profile","text":"","category":"section"},{"location":"examples/","page":"-","title":"-","text":"dom = CartesianDomain(-5:0.1:5, -4:0.1:4)\nmodel = Model(dom,\n              :background => GModelFit.OffsetSlope(0, 0, 0., 2., 3.),\n              :psf => GModelFit.Gaussian(100., 0., 0., 1, 0.3, 15), \n\t\t\t  :main => SumReducer(:background, :psf))\ndata = GModelFit.mock(Measures, model)\nret1 = fit(model, data)","category":"page"},{"location":"examples/","page":"-","title":"-","text":"To produce the plots I will use the Gnuplot.jl package, but the user can choose any other package:","category":"page"},{"location":"examples/","page":"-","title":"-","text":"using Gnuplot\n\n# Plot the model...\n@gsp coords(dom, 1) coords(dom, 2) model()\n\n# ...and the residuals\n@gsp coords(dom, 1) coords(dom, 2) values(data) - model()\n\n# Plot using pm3d style\n@gsp \"set pm3d\" \"set palette\" coords(dom, 1) coords(dom, 2) model() \"w dots\"","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"include(\"setup.jl\")","category":"page"},{"location":"parameter/#Parameter-constraints","page":"Parameter constraints","title":"Parameter constraints","text":"","category":"section"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"Models are characterized by parameters (see Basic concepts and data types) whose values are modified during fitting until a convergence criterion is met, and the best fit values are identified.  In many cases, however, the parameters can not vary arbitrarily but should satisfy some constraints for their values to be meaningful.  GModelFit.jl supports the definition of constraints by fixing the parameter to a specific value, limiting the value in a user defined range, or by dynamically calculating its value using a mathematical expression involving other parameter values.  In the latter case the parameter is not free to vary in the fit since its actual value is determined by the patch constraint, hence it is dubbed a patched parameter.  Such unused parameter can optionally be repurposed as a new free parameter in a parametrized patch expression (see example below).","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"An important concept to bear in mind is that the GModelFit.Parameter structure provides two field for the associated numerical value:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"val: is the parameter value which is being varied by the minimizer during fitting.  The value set before the fitting is the guess value.  The value after fitting is the best fit one;\nactual: is the result of the patch expression evaluation, and the actual value used when evaluating a component via its evaluate! method.  Note that this value will be overwitten at each model evaluation, hence setting this field has no effect. The val and actual values are identical if no patch constraint has been defined.","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"A parameter constraint is defined by explicitly modifiying the fields of the corresponding GModelFit.Parameter structure. More specifically:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"to set a parameter to a specific value: set the val field to the numeric value and set the fixed field to true;\nto set a parameter value range: set one or both the low and high fields (default values are -Inf and +Inf respectively);\nto constraint a parameter to have the same numerical value as another one with the same name (but in another component): set the patch value to the component name (it must be a Symbol);\nto dynamically calculate an actual value using a mathematical expression depending on other parameter values: set the patch field to an anonymous function generated with the @fd macro.  The function must accept a single argument (actually a dictionary of components) and return a scalar numberl;\nto define a parametrized patch expression: create an anonymous function with the @fd macro with two arguments, the first has the same meaning as in the previous case, and the second is the free parameter value.  Note that patched parameter loses its original meaning, and becomes the parameter of the patch expression;\nto define a patch constraint involving parameters from other models in a Multi-dataset fitting scenario: simply use mpatch in place of patch, and the first argument to the λ-function will be a vector with as many elements as the number of models in the Vector{Model} object.","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"The following examples show how to define constraints for each of the afore-mentioned cases.","category":"page"},{"location":"parameter/#Example","page":"Parameter constraints","title":"Example","text":"","category":"section"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"We will consider a model for a 1D domain consisting of the sum of a linear background component (named bkg) and two Gaussian-shaped features (l1 and l2):","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"using GModelFit\n\nmodel = Model(:bkg => GModelFit.OffsetSlope(1, 1, 0.1),\n              :l1 => GModelFit.Gaussian(1, 2, 0.2),\n              :l2 => GModelFit.Gaussian(1, 3, 0.4),\n              :main => SumReducer(:bkg, :l1, :l2))\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"Assume that, for the model to be meaningful, the parameters should satisfy the following constraints:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the bkg should have a fixed value of 1 at x=1, and a slope which is in the range [0:0.2]:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:bkg].offset.val = 1\nmodel[:bkg].offset.fixed = true\n\nmodel[:bkg].slope.low  = 0\nmodel[:bkg].slope.high = 0.2\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the normalization of l1 and l2 must be the same:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:l2].norm.patch = :l1\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the width of l2 must be twice that of l1 (patched parameter):","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:l2].sigma.patch = @fd m -> 2 * m[:l1].sigma\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"the center of l2 must be at a larger coordinate with respect to the center of l1.  In this case we re-interpret the model[:l2].center parameter as the distance between the two centers, and create a parametrized patch expression to calculate the actual center value of l2:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"model[:l2].center.patch = @fd (m, v) -> v + m[:l1].center\nmodel[:l2].center.val = 1   # guess value for the distance between the centers\nmodel[:l2].center.low = 0   # ensure [l2].center > [l1].center\nprintln() # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"We can fit the model against a mock dataset (see Generate mock datasets):","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"dom = Domain(0:0.1:5)\ndata = GModelFit.mock(Measures, model, dom)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"and plot the results with Gnuplot.jl:","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"using Gnuplot\n@gp    coords(dom) values(data) uncerts(data) \"w yerr t 'Data'\" :-\n@gp :- coords(dom) model(dom) \"w l t 'Model'\"\nsaveas(\"example_patch1\") # hide","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"(Image: )","category":"page"},{"location":"parameter/","page":"Parameter constraints","title":"Parameter constraints","text":"See Multi-dataset fitting for an example on how to create a patch epression involving multiple models.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"include(\"setup.jl\")","category":"page"},{"location":"builtincomp/#Built-in-components","page":"Built-in components","title":"Built-in components","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The GModelFit.jl provides several built-in components which may be used to build arbitrarily complex models.","category":"page"},{"location":"builtincomp/#OffsetSlope","page":"Built-in components","title":"OffsetSlope","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"An offset and slope component for 1D and 2D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D: GModelFit.OffsetSlope(offset, x0, slope);\n2D: GModelFit.OffsetSlope(offset, x0, y0, slopeX, slopeY);","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslope::Parameter: the slope of the linear function;\n2D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\ny0::Parameter: the Y coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslopeX::Parameter (only 2D): the slope of the plane along the X direction;\nslopeY::Parameter (only 2D): the slope of the plane along the Y direction;","category":"page"},{"location":"builtincomp/#Example","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a linear model using the OffsetSlope component\nmodel = Model(:linear => GModelFit.OffsetSlope(2, 0, 0.5))\n\n# Fit model against data\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The best fit parameter values can be retrieved with:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"println(\"Best fit values:\")\nprintln(\"b:  \", bestfit[:linear].offset.val, \" ± \", bestfit[:linear].offset.unc)\nprintln(\"m:  \", bestfit[:linear].slope.val , \" ± \", bestfit[:linear].slope.unc)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A similar example in 2D is as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a linear model using the OffsetSlope component\nmodel = Model(:plane => GModelFit.OffsetSlope(2, 0, 0, 0.5, 0.5))\n\n# Fit model against data\ndom = CartesianDomain(1:5, 1:5)\ndata = Measures(dom, [ 3.08403  3.46719  4.07612  4.25611  5.04716\n                       3.18361  3.88546  4.52338  5.12838  5.7864\n                       3.80219  4.90894  5.24232  5.06982  6.29545\n                       4.34554  4.68698  5.51505  5.69245  6.35409\n                       4.643    5.91825  6.18011  6.67073  7.01467], 0.25)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/#Polynomial","page":"Built-in components","title":"Polynomial","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A n-th degree polynomial function (n > 1) for 1D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructor is defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"GModelFit.Polynomial(p1, p2, ...); where p1, p2, etc. are the guess values for the coefficients of each degree of the polynomial.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are accessible as p0, p1, etc.","category":"page"},{"location":"builtincomp/#Example-2","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define domain and a linear model using the Polynomial component\nmodel = Model(GModelFit.Polynomial(2, 0.5))\n\n# Fit model against data\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"Note that the numerical results are identical to the previous example involving the OffsetSlope component.  Also note that the default name for a component (if none is provided) is :main.  To use a 2nd degree polynomial we can simply replace the :main component with a new one:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"model[:main] = GModelFit.Polynomial(2, 0.5, 1)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/#Gaussian","page":"Built-in components","title":"Gaussian","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A normalized Gaussian component for 1D and 2D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D: GModelFit.Gaussian(norm, center, sigma);\n2D: GModelFit.Gaussian(norm, centerX, centerY, sigma) (implies sigmaX=sigmaY, angle=0);\n2D: GModelFit.Gaussian(norm, centerX, centerY, sigmaX, sigmaY, angle);","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D:\nnorm::Parameter: the area below the Gaussian function;\ncenter::Parameter: the location of the center of the Gaussian;\nsigma::Parameter: the width the Gaussian;\n2D:\nnorm::Parameter: the volume below the Gaussian function;\ncenterX::Parameter: the X coordinate of the center of the Gaussian;\ncenterY::Parameter: the Y coordinate of the center of the Gaussian;\nsigmaX::Parameter: the width the Gaussian along the X direction (when angle=0);\nsigmaY::Parameter: the width the Gaussian along the Y direction (when angle=0);\nangle::Parameter: the rotation angle (in degrees) of the Gaussian.","category":"page"},{"location":"builtincomp/#Example-3","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a model with a single Gaussian component\nmodel = Model(GModelFit.Gaussian(1, 3, 0.5))\n\n# Fit model against data\ndata = Measures([0, 0.3, 6.2, 25.4, 37.6, 23., 7.1, 0.4, 0], 0.6)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A very common problem is to fit the histogram of a distribution with a Gaussian model.  The following example shows how to fit such Gaussian model to a distribution generated with Random.randn, and how to plot the results using Gnuplot.jl:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using Random, GModelFit, Gnuplot\n\n# Calculate histogram of the distribution\nhh = hist(randn(10000), bs=0.25)\n\n# Define domain and data and fit a model\ndom = Domain(hist_bins(hh, side=:center, pad=false))\ndata = Measures(dom, hist_weights(hh, pad=false), 1.)\nmodel = Model(GModelFit.Gaussian(1e3, 0, 1))\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"@gp hh coords(dom) bestfit() \"w l t 'Model' lw 3\"\nsaveas(\"gaussian\") # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"(Image: )","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A similar problem in 2D can be handled as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using Random, GModelFit, Gnuplot\n\n# Calculate histogram of the distribution\nhh = hist(1 .+ randn(10000), 2 .* randn(10000))\n\n# Define domain and data and fit a model\ndom = CartesianDomain(hist_bins(hh, 1), hist_bins(hh, 2))\ndata = Measures(dom, hist_weights(hh) .* 1., 1.)\nmodel = Model(GModelFit.Gaussian(1e3, 0, 0, 1, 1, 0))\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/#FComp","page":"Built-in components","title":"FComp","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"As anticipated in Basic concepts and data types any Julia function can be used as a component to evaluate.  The corresponding component type is FComp, whose constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"FComp(funct::Function, deps=Symbol[]; par1=guess1, par2=guess2, ...)\nFComp(funct::FunctDesc)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"In the first constructor funct is the Julia function, deps is a vector of dependencies (either the domain dimensions or other component names) and par1, par2 etc. are the named parameters with their corresponding initial guess values.","category":"page"},{"location":"builtincomp/#Example-4","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a simple Julia function to evaluate a linear relationship\nmyfunc(x, b, m) = b .+ x .* m\n\n# Define a model with a `FComp` wrapping the previously defined function.\n# Also specify the initial guess parameters.\nmodel = Model(:linear => GModelFit.FComp(myfunc, [:x], b=2, m=0.5))\n\n# Fit model against a data set\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"In the second constructor a GModelFit.FunctDesc object is accepted, as generated by the @fd macro).  The function is typically a mathematical expression combining any number of parameters and/or other component evaluations within the same model.  The expression should be given in the form:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"@fd (x, [y, [further domain dimensions...],]\n    [comp1, [comp2, [further components ...],]]\n    [par1=guess1, [par2=guess2, [further parameters]]]) ->\n    (mathematical expression)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"where the mathematical expression returns a Vector{Float64} with the same length as the model domain.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The previous example can be rewritten as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define a linear model (with initial guess parameters)\nmodel = Model(:linear => @fd (x, b=2, m=0.5) -> (b .+ x .* m))\n\n# Fit model against data\ndata = Measures([4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"Note that a FComp component can be added to a model without explicitly invoking its constructor when the @fd macro is used.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The evaluation of a FComp component may also involve the outcomes from other components. Continuing from previous example, whose fit was clearly a poor one, we may add a quadratic term to the previously defined linear component:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"model[:quadratic] = @fd (x, linear, p2=1) -> (linear .+ p2 .* x.^2)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The keywords given when defining the function are interpreted as component parameters, hence their properties can be retrieved with:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"println(\"Best fit values:\")\nprintln(\"b:  \", bestfit[:linear].b.val    , \" ± \", bestfit[:linear].b.unc)\nprintln(\"m:  \", bestfit[:linear].m.val    , \" ± \", bestfit[:linear].m.unc)\nprintln(\"p2: \", bestfit[:quadratic].p2.val, \" ± \", bestfit[:quadratic].p2.unc)","category":"page"},{"location":"builtincomp/#FCompv","page":"Built-in components","title":"FCompv","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"Just like FComp, also FCompv is a wrapper for a standard Julia function whose evaluation is performed using the function itself.  However, FCompv parameters are passed to the function as a single vector of floats.  The FCompv constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"FComp(funct::Function, guess::Vector{Float64})\nFComp(funct::Function, deps::Vector{Symbol}, guess::Vector{Float64})","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"where funct is the Julia function, deps is an optional vector of dependencies (either the domain dimensions or other component names) and guess is a vector of initial guess values.","category":"page"},{"location":"builtincomp/#Example-5","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The following example shows how to estimate the vector x satisfying the linear equation Ax = b, where A and b are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A = [1.43  2.17 -0.38\n     0.21 -0.33 -1.71\n    -1.23 -1.16  0.83\n    -2.09  0.44  0.64]\nb = [3.14, -8.48, 0.53, 0.54]\nprintln() # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"To define the model we will rewrite the equation as Ax - b = 0, and define a model as follows","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"model = Model(GModelFit.FCompv(x -> A*x - b,\n                               [1, 1, 1]))\nprintln() # hide","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"where x = [1, 1, 1] are the initial guess values for the three parameters in the fit.  In this case the empirical data to compare the model to are just zeros, and we will assume a constant uncertainty of 1 for all samples:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"data = Measures(fill(0., length(b)), 1.)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"builtincomp/#SumReducer","page":"Built-in components","title":"SumReducer","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A component calculating the element-wise sum of a number of other components.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The SumReducer constructor is defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"SumReducer(args::AbstractSet{Symbol})\nSumReducer(args::Vector{Symbol})\nSumReducer(args::Vararg{Symbol})","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"where the Symbols represent the component names","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The SumReducer component has no parameter.","category":"page"},{"location":"builtincomp/#Example-6","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"using GModelFit\n\n# Define domain and a linear model (with initial guess parameters)\nmodel = Model(:linear => @fd (x, b=2, m=0.5) -> (b .+ x .* m))\n\n# Add a quadratic component to the model\nmodel[:quadratic] = @fd (x, p2=1) -> (p2 .* x.^2)\n\n# The total model is the sum of `linear` and `quadratic`\nmodel[:main] = SumReducer(:linear, :quadratic)\n\n# Fit model against data\ndom = Domain(1:5)\ndata = Measures(dom, [4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"minimizers/#Minimizers","page":"Minimizers","title":"Minimizers","text":"","category":"section"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"The GModelFit.jl main purpose is to act as an high-level interface between the user and the underlying minimizer. Currently, two non-linear least squares minimizers are supported:","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"LsqFit;\nCMPFit.","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"More minimizers may be added in the future.","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"To choose a specific minimizer use the minimizer= keyword when invoking the fit() function, e.g. minimizer=GModelFit.lsqfit() or minimizer=GModelFit.cmpfit().  If the keyword is not provided the lsqfit() minimizer is used.","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"There is also a dummy minimizer, GModelFit.dry(), whose purpose is to compare the model and the data, and to generate a FitStats object without modifying the model parameters.  The dry minimizer is used by the compare() function.","category":"page"},{"location":"minimizers/#Examples","page":"Minimizers","title":"Examples","text":"","category":"section"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"using GModelFit\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\ndata = GModelFit.mock(Measures, model, Domain(1:0.1:50), seed=1)\nbestfit, stats = fit(model, data, minimizer=GModelFit.lsqfit())\nprintln(); # hide","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"or","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"bestfit, stats = fit(model, data, minimizer=GModelFit.cmpfit())\nprintln(); # hide","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"The above minimizers typically provide the same results, although in some complex case the CMPFit may be more robust and less sensitive to initial guess parameters.","category":"page"},{"location":"minimizers/#The-cmpfit()-minimizer","page":"Minimizers","title":"The cmpfit() minimizer","text":"","category":"section"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"The cmpfit() minimizer allows to specify several options to fine-tune the minimizer behaviour.  Specifically:","category":"page"},{"location":"minimizers/","page":"Minimizers","title":"Minimizers","text":"the CMPFit.Config structure allows to specify the convergence criteria, the maximum number of iterations, etc. (see the \"CONFIGURING MPFIT()\" section here;\nthe ftol_after_maxiter allows to specify a threshold on the relative difference in fit statistics before and after the mpfit() execution.  If the latter terminates because the maximum number of iterations has been reached, and the relative difference in fit statistics is still greater than ftol_after_maxiter the minimization process will continue.  E.g.:\nusing GModelFit\ndom = Domain(1:0.1:50)\nmodel = Model(:main => @fd (x, T=3.14) -> sin.(x ./ T) ./ (x ./ T))\ndata = GModelFit.mock(Measures, model, dom, seed=1)\n\n# Set minimizer options\nmzer = GModelFit.cmpfit()\nmzer.config.maxiter = 1\nmzer.ftol_after_maxiter = 1e-8\n\n# Run the fit\nmodel[:main].T.val = 10  # guess value, purposely far from true one\nbestfit, stats = fit(model, data, minimizer=mzer)\nprintln(); # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"setup.jl\")","category":"page"},{"location":"#GModelFit.jl","page":"Home","title":"GModelFit.jl","text":"","category":"section"},{"location":"#A-model-fitting-framework-for-Julia.","page":"Home","title":"A model fitting framework for Julia.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stars)","category":"page"},{"location":"","page":"Home","title":"Home","text":"GModelFit.jl is a general purpose, data-driven model fitting framework for Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides the basic tools to define, interactively manipulate and efficiently evaluate a (possibly very complex) model, and to fit the latter to empirical data. The main functionalities are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"it handles datasets of any dimensionality;\nthe syntax is very simple and concise as it resembles the indexing for dictionaries and the field access for structs.  The most relevant functions are the self-explanatory fit() and the object constructors (see Main functions);\nthe fitting model is evaluated on a user defined domain, and is the result of a combination of model components or mathematical expressions (in the form of lambda functions), or any arbitrary mixture of the two;\nit provides several ready-to-use Built-in components, and it also allows to define new components to suit specific needs (Custom components);\nall components results are cached so that repeated evaluations with the same parameter values do not involve further calculations (memoization);\nmodel parameters can be fixed to a specific value, limited in an interval, and/or be dynamically linked (patched) to the values of other parameters (see Parameter constraints);\nmultiple data sets can be fitted simultaneously against different models whose parameters can be patched (see Multi-dataset fitting);\nit supports different minimizers (LsqFit and CMPFit), both aimed to carry out non-linear least squares minimization (see Minimizers);\nit provides facilities for interactive fitting and quick plotting (see Quick plot (1D)).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The fitting process involves the automatic variation of the parameter values, subject to the user defined constraints, until the differences between the evaluated model and the empirical data are minimized. The implementation details depends on the chosen minimizer.  The purpose of GModelFit.jl is thus to act as an interface between the high-level model definition and manipulation (facing the user), and the low-level implementation details (facing the minimizer).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add GModelFit","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ] character starts the Julia package manager. Hit backspace key to return to Julia prompt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to easily visualize the outcomes of 1D analysis you may be interested in installing also Gnuplot.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add Gnuplot","category":"page"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The typical workflow to use GModelFit.jl is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Wrap empirical data domain and measures into one (ore more) Domain and Measures object(s);\nCreate a Model object  by providing components or mathematical expressions, each representing a specific aspect of the theoretical model;\nOptionally set initial guess parameter values and/or constraints between model parameters;\nFit the model against the data and inspect the results;\nIf needed, modify the model and repeat the fitting process;\nExploit the results and outputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A very simple example showing the above workflow is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GModelFit\n\n# Prepare vectors with domain points, empirical measures and associated\n# uncertainties\nx    = [0.1, 1.1, 2.1, 3.1, 4.1]\nmeas = [6.29, 7.27, 10.41, 18.67, 25.3]\nunc  = [1.1, 1.1, 1.1, 1.2, 1.2]\n\n# Prepare Domain and Measures objects\ndom  = Domain(x)\ndata = Measures(dom, meas, unc)\n\n# Create a model using an explicit mathematical expression, and provide the\n# initial guess values:\nmodel = Model(@fd (x, a2=1, a1=1, a0=5) -> (a2 .* x.^2  .+  a1 .* x  .+  a0))\n\n# Fit model to the data\nbestfit, stats = fit(model, data)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The GModelFit.jl package implements a show method for many of the data types involved, hence the above code results in the following output:","category":"page"},{"location":"","page":"Home","title":"Home","text":"show((bestfit, stats)) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing the best fit parameter values and the associated uncertaintites, as well as a few statistics concerning the fitting process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If not saitisfied with the result you may, for instance, change the initial value for a parameter and re-run the fit:","category":"page"},{"location":"","page":"Home","title":"Home","text":"model[:main].a0.val = 5\nbestfit, stats = fit(model, data)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once done, you may plot the data and the best fit model with a plotting framework of your choice. E.g., with Gnuplot.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Gnuplot\n@gp coords(dom) values(data) uncerts(data) \"w yerr t 'Data'\" :-\n@gp :- coords(dom) bestfit() \"w l t 'Best fit model'\"\nsaveas(\"simple_example\"); # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, you can easily access the numerical results for further analysis, e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"println(\"Best fit value for the offset parameter: \", \n\tbestfit[:main].a0.val, \" ± \", \n\tbestfit[:main].a0.unc, \"\\n\",\n\t\"Reduced χ^2: \", stats.fitstat)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above example is definitely a simple one, but more complex ones follow essentially the same workflow.","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"include(\"setup.jl\")","category":"page"},{"location":"customcomp/#Custom-components","page":"Custom components","title":"Custom components","text":"","category":"section"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"Besides the Built-in components, the user may define any number of custom components to be used in a model.  Before continuing be sure to read the GModelFit internals section.","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"A user-defined component shall satisfy the following three constraints:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"It shall be a structure inheriting from GModelFit.AbstractComponent;\nThe component parameters (if present) shall be defined as fields with type Parameter, e.g.:\nstruct MyComponent <: AbstractComponent\n    param1::Parameter\n    param2::Parameter\n    ...\nend\n(see below for a complete example).   Alternatively, the parameters may be specified as a single field of type OrderedDict{Symbol, Parameter} (see the Polynomial component for an example).  The structure may also contain further fields of any type;\nThe GModelFit.evaluate! function shall be extended to provide the component-specific code for evaluation.  Specifically, it should replace the content of the CompEval.buffer vector with the outcome of the new component evaluation, using the parameter values provided as arguments, e.g.\nfunction evaluate!(ceval::CompEval{MyComponent},\n                   param1::Float64, param2::Float64...)\n  ceval.buffer .= (component evaluation using param1 and param2 values)\nend","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"Optionally, the user may choose to extend also the following functions:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"GModelFit.prepare!: to prepare the component for evaluations on a specific domain (e.g. to pre-compute quantities which depend only on the domain being used).  The return value must be a Vector{Float64} to accomodate the component evaluation, this will be used as buffer field of the corresponding GModelFit.CompEval structure.  If not implemented, the default  implementation will simply creates a buffer with the same length as the input domain;\nGModelFit.dependencies: to specify the list of the component dependencies.  The evaluation of the latter will be made available via the deps field of the  GModelFit.CompEval structure.  Return value shall be a Vector{Symbol}, and the default implementation returns an empty list Symbol[].","category":"page"},{"location":"customcomp/#Life-cycle-of-a-component","page":"Custom components","title":"Life cycle of a component","text":"","category":"section"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The typical life cycle of a component is as follows:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The component is created by invoking its constructor and is added to a Model object before any evaluation;\nThe user may optionally modify the component parameter initial values, as well as their Parameter constraints, before starting the fit;\nWhen the fit function is invoked, all components in a Model are wrapped into GModelFit.CompEval objects, and the latter are collected into a GModelFit.ModelEval object (also containing the original Model);\nDuring the creation of the CompEval object the component GModelFit.prepare! function is called to allocate the proper buffer for evaluations.  Note that the prepare! function is invoked only once for each fit invocation, hence it is the perfect place to pre-compute quantities which will be used during the component evaluation.  The domain for component evaluation is obtained from the Measures object provided as argument to the fit function;\nDuring the creation of the GModelFit.ModelEval object a a dependency tree is generated by invoking the GModelFit.dependencies function for all components. The tree is used to identify the proper order for component evaluations: the leaves will be evaluated first, and the remaining ones will be evaluated following the tree branches up to the root, dubbed main component.  The evaluation of the latter will be compared to the data;\nDuring the fitting process the component GModelFit.evaluate! function is invoked whenever a change in its parameter values is detected, until a convergence criterion is satisfied.","category":"page"},{"location":"customcomp/#Example","page":"Custom components","title":"Example","text":"","category":"section"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"A common case is to compare empirical data with a numerically evaluated theoretical model, possibly defined on a different grid with respect to the empirical one.  An interpolation is therefore required in order to compare the model to the data.","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"Let's assume the theoretical model is defined as follows:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"theory_x = 0.:10\ntheory_y = [0, 0.841, 0.909, 0.141, -0.757, -0.959, -0.279, 0.657, 0.989, 0.412, -0.544]\nprintln() # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"while the empirical data are:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"obs_x = [0.500, 2.071, 3.642, 5.212, 6.783, 8.354, 9.925]\nobs_y = [2.048, 3.481, 1.060, 0.515, 3.220, 4.398, 1.808]\nprintln() # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The following example shows how to implement a component which interpolates a theoretical model onto a specific empirical domain, with the only parameter being a global scaling factor:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"using GModelFit, Interpolations\nimport GModelFit.prepare!, GModelFit.evaluate!\n\n# Define the component structure and constructor\nstruct Interpolator <: GModelFit.AbstractComponent\n    theory_x::Vector{Float64}\n    theory_y::Vector{Float64}\n    interp_y::Vector{Float64}  # will contain the interpolated values\n    scale::GModelFit.Parameter\n\n    function Interpolator(theory_x, theory_y)\n        scale = GModelFit.Parameter(1)\n        scale.low = 0                  # ensure scale parameter is positive\n        interp_y = Vector{Float64}()   # this will be populated in prepare!()\n        return new(theory_x, theory_y, interp_y, scale)\n    end\nend\n\n# Component preparation: invoked only once to precompute quantities\n# and allocate evaluation buffer\nfunction prepare!(comp::Interpolator, domain::AbstractDomain{1})\n    # Pre-compute interpolation on the empirical domain\n    itp = linear_interpolation(comp.theory_x, comp.theory_y)\n    append!(comp.interp_y, itp(coords(domain)))\n    return fill(NaN, length(comp.interp_y)) # buffer for evaluations\nend\n\n# Component evaluation (apply scaling factor)\nfunction evaluate!(ceval::GModelFit.CompEval{Interpolator, <: AbstractDomain{1}},\n                   scale)\n    ceval.buffer .= scale .* ceval.comp.interp_y\nend\nprintln() # hide","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"The following code shows how to prepare a Model including the interpolated theoretical model, and to take into account the possible background introduced by the detector used to obtain empirical data:","category":"page"},{"location":"customcomp/","page":"Custom components","title":"Custom components","text":"model = Model(:theory => Interpolator(theory_x, theory_y),\n              :background => GModelFit.OffsetSlope(1., 0., 0.2),\n              :main => SumReducer(:theory, :background))\n\ndata = Measures(Domain(obs_x), obs_y, 0.2)\nbestfit, stats = fit(model, data)\nshow((bestfit, stats)) # hide","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"include(\"setup.jl\")","category":"page"},{"location":"multifit/#Multi-dataset-fitting","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"","category":"section"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"GModelFit.jl is able to simultaneously fit several models against a corresponding number of datasets, while placing constraints among the models. Typical use cases are:","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"a single phenomenon is observed with two (or more) instruments/detectors;\na single phenomenon is observed at different times;","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"Fitting multiple datasets simultaneously may provide tighter constraints on the best fit parameters under the assumption that the models are somehow related, i.e. that their parameters are constrained (or patched).","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"To perform a multi-dataset fitting we should create one Model for each dataset in the usual way, collect them in a Vector{Model}, and define patch constraints among models.   The following example shows how to fit two Gaussian curves under the hypotesis that the center and normalization parameters are the same:","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"using GModelFit\n\n# Create individual models and the Vector{Model} container\nmodel1 = Model(GModelFit.Gaussian(1, 0., 1.))\nmodel2 = Model(GModelFit.Gaussian(1, 0., 1.))\nmulti = [model1, model2]\n\n# Patch parameters\nmulti[2][:main].norm.mpatch   = @fd m -> m[1][:main].norm\nmulti[2][:main].center.mpatch = @fd m -> m[1][:main].center\n\n# Create datasets and fit\ndom = Domain(-5.:5)\ndata1 = Measures(dom, [-0.006,  0.015,  0.001,  0.049,  0.198,  0.430,  0.226,  0.048,  0.017, -0.001, -0.006], 0.04)\ndata2 = Measures(dom, [-0.072, -0.033, -0.070,  0.108,  0.168,  0.765,  0.113, -0.054,  0.032,  0.013,  0.015], 0.04)\nbestfit, stats = fit(multi, [data1, data2])\nshow((bestfit, stats)) # hide","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"The best fit models and values are returned as a Vector{ModelSnapshot} in bestfit, i.e.:","category":"page"},{"location":"multifit/","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"println(\"Width of Gaussian 1: \", bestfit[1][:main].sigma.val, \" ± \", bestfit[1][:main].sigma.unc)\nprintln(\"Width of Gaussian 2: \", bestfit[2][:main].sigma.val, \" ± \", bestfit[2][:main].sigma.unc)\nprintln(\"Reduced χ^2: \", stats.fitstat)","category":"page"}]
}
