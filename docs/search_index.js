var documenterSearchIndex = {"docs":
[{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"using Gnuplot\nGnuplot.quitall()\nmkpath(\"assets\")\nGnuplot.options.term = \"unknown\"\nempty!(Gnuplot.options.init)\npush!( Gnuplot.options.init, linetypes(:Set1_5, lw=2.5, ps=1.5))\nsaveas(file) = save(term=\"pngcairo size 550,350 fontscale 0.8\", output=\"assets/$(file).png\")","category":"page"},{"location":"parameter.html#Parameter-constraints","page":"Parameter constraints","title":"Parameter constraints","text":"","category":"section"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"Models are characterized by parameters whose values are modified during fitting until a convergence criterion is met, and the best fit values are identified.  In many cases, however, the parameters can not vary arbitrarily but should satisfy some constraints for their values to be meaningful.  GFit.jl supports the definition of parameter constraints in two flavours:","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"the parameter can be fixed to a specific value, or limited in a range of values;\nthe parameter can be dynamically calculated, based on other parameter values.","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"In the latter case the parameters are said to be patched through a mathematical relationship.","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"A parameter constraint is defined by directly modifiying the structure of the corresponding GFit.Parameter structure.  Note that such structure provides two field for the associated numerical value:","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"val: is the parameter value which is being varied by the minimizer during fitting.  The value set before the fitting is the guess value.  The value after fitting is the best fit one;\nactual: is the actual parameter value, as calculated by the patch expression.  Note that the value will be overwitten at each model evaluation, hence setting this field has no effect.","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"The val and actual values are identical if no patch constraint has been defined.","category":"page"},{"location":"parameter.html#Example","page":"Parameter constraints","title":"Example","text":"","category":"section"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"The following shows how to implement the afore-mentioned constraints (note that here we use the GFit.mock() function to generate Generate mock datasets):","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"using GFit\n\ndom = Domain(0:0.1:6)\nmodel = Model(dom, :l1 => GFit.Gaussian(1, 2, 0.2),\n                   :l2 => GFit.Gaussian(1, 3, 0.5),\n                   :bkg => GFit.OffsetSlope(0.5, 1, 0.1),\n                   :main => SumReducer(:bkg, :l1, :l2));\ndata = GFit.mock(Measures, model)\n\nres = fit!(model, data)\n@gp    coords(dom) values(data) uncerts(data) \"w yerr t 'Data'\" :- # hide\n@gp :- coords(dom) model() \"w l t 'Model'\" # hide\nsaveas(\"example_patch1\") # hide","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"(Image: )","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"and can not be modified during the fitting process.  To fix a Parameter object simply set its fixed field to true;","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"limited range: the parameter is allowed to vary only within a range limited by the low and high fields values;\nthe current parameter value can be constrained to be equal to that of another parameter with the same name, but belonging to another component within the same model.  To establish such link simply set the component name in the patch field;\nthe current parameter value can be dynamically calculated by a mathematical expression involving all other parameters within the same model. In this case the patch should be set to a @λ function with a single argument.  The parameter is au","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"containing both the parameter numerical value and the constraint prescriptions. Note that ","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"The current value, in particular, is modified during the fitting process to minimize the differences between the model and the data.  The possible values for each parameter can be either unspecified (i.e. the value can be anything from -Inf to +Inf) or subject to a number of constraints. ","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"The possible constraints are:","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"fixed parameter: the parameter is fixed to a specific value and can not be modified during the fitting process.  To fix a Parameter object simply set its fixed field to true;\nlimited range: the parameter is allowed to vary only within a range limited by the low and high fields values;\nthe current parameter value can be constrained to be equal to that of another parameter with the same name, but belonging to another component within the same model.  To establish such link simply set the component name in the patch field;\nthe current parameter value can be dynamically calculated by a mathematical expression involving all other parameters within the same model. In this case the patch should be set to a @λ function with a single argument.  The parameter is au","category":"page"},{"location":"parameter.html","page":"Parameter constraints","title":"Parameter constraints","text":"model parameters can be fixed to a specific value, limited in an interval, and/or be dynamically linked (patched) to the values of other parameters (see Parameter constraints);","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using Gnuplot\nGnuplot.quitall()\nmkpath(\"assets\")\nGnuplot.options.term = \"unknown\"\nempty!(Gnuplot.options.init)\npush!( Gnuplot.options.init, linetypes(:Set1_5, lw=2.5, ps=1.5))\nsaveas(file) = save(term=\"pngcairo size 550,350 fontscale 0.8\", output=\"assets/$(file).png\")","category":"page"},{"location":"builtincomp.html#Built-in-components","page":"Built-in components","title":"Built-in components","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The GFit.jl provides several built-in components which may be used to build arbitrarily complex models.","category":"page"},{"location":"builtincomp.html#λComp","page":"Built-in components","title":"λComp","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The λComp component is a wrapper for a user defined lambda function (namely a GFit.λFunct object, as obtained by the @λ macro).  The function is typically a mathematical expression combining any number of parameters and/or other component evaluations within the same model.  The expression should be given in the form:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"@λ (x, [y, [further domain dimensions...],]\n    [comp1, [comp2, [further components ...],]]\n    [p1=guess value, [p2=guess value, [further parameters]]]) ->\n\t(mathematical expression)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"where the mathematical expression returns a Vector{Float64} with the same length as the model domain (regardless of the number of dimensions involved).","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The λComp constructor is defined as follows:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"λComp(f::λFunct)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"however there is no need to explicitly invoke such constructor since a λComp object is automatically created whenever a λFunct is added to the model. This components works with domains of any dimensionality.","category":"page"},{"location":"builtincomp.html#Examples","page":"Built-in components","title":"Examples","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using GFit\n\n# Prepare domain and a linear model (with initial guess parameters)\ndom = Domain(1:5)\nmodel = Model(dom, :linear => @λ (x, b=2, m=0.5) -> (b .+ x .* m))\n\n# Fit model against data\ndata = Measures(dom, [4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The evaluation of a λComp component may also involve the outcomes from other components. Continuing from previous example, whose fit was clearly a poor one, we may add a quadratic term to the previously defined linear component:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"model[:quadratic] = @λ (x, linear, p2=1) -> (linear .+ p2 .* x.^2)\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"Note that the keywords given when defining the function are interpreted as component parameters, hence their properties can be retrieved with:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"println(\"Best fit values:\")\nprintln(\"b:  \", res.bestfit[:linear].b.val , \" ± \", res.bestfit[:linear].b.unc)\nprintln(\"m:  \", res.bestfit[:linear].m.val , \" ± \", res.bestfit[:linear].m.unc)\nprintln(\"p2: \", res.bestfit[:quadratic].p2.val, \" ± \", res.bestfit[:quadratic].p2.unc)","category":"page"},{"location":"builtincomp.html#OffsetSlope","page":"Built-in components","title":"OffsetSlope","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"An offset and slope component for 1D and 2D domains.","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"1D: GFit.Components.OffsetSlope(offset, x0, slope);\n2D: GFit.Components.OffsetSlope(offset, x0, y0, slopeX, slopeY);","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"1D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslope::Parameter: the slope of the linear function;\n2D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\ny0::Parameter: the Y coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslopeX::Parameter (only 2D): the slope of the plane along the X direction;\nslopeY::Parameter (only 2D): the slope of the plane along the Y direction;","category":"page"},{"location":"builtincomp.html#Examples-2","page":"Built-in components","title":"Examples","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using GFit\n\n# Prepare domain and a linear model using the OffsetSlope component\ndom = Domain(1:5)\nmodel = Model(dom, :linear => GFit.OffsetSlope(2, 0, 0.5))\n\n# Fit model against data\ndata = Measures(dom, [4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"Note that the numerical results are identical to the previous example (where an explicit mathematical expression for the :linear component was used).","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"A similar example in 2D is as follows:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using GFit\n\n# Prepare domain and a linear model using the OffsetSlope component\ndom = CartesianDomain(1:5, 1:5)\nmodel = Model(dom, :plane => GFit.OffsetSlope(2, 0, 0, 0.5, 0.5))\n\n# Fit model against data\ndata = Measures(dom, [ 3.08403  3.46719  4.07612  4.25611  5.04716\n                       3.18361  3.88546  4.52338  5.12838  5.7864\n                       3.80219  4.90894  5.24232  5.06982  6.29545\n                       4.34554  4.68698  5.51505  5.69245  6.35409\n                       4.643    5.91825  6.18011  6.67073  7.01467], 0.25)\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html#Polynomial","page":"Built-in components","title":"Polynomial","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"A n-th degree polynomial function (n > 1) for 1D domains.","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The constructor is defined as follows:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"GFit.Polynomial(p1, p2, ...); where p1, p2, etc. are the guess values for the coefficients of each degree of the polynomial.","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The parameters are labelled: p1, p2, etc.","category":"page"},{"location":"builtincomp.html#Examples-3","page":"Built-in components","title":"Examples","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using GFit\n\n# Prepare domain and a linear model using the Polynomial component\ndom = Domain(1:5)\nmodel = Model(dom, GFit.Polynomial(2, 0.5))\n\n# Fit model against data\ndata = Measures(dom, [4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"Note again that the numerical results are identical to the previous examples.  Also note that the default name for a component (if none is provided) is :main.  To use a 2nd degree polynomial we can simply replace the :main component with a new one:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"model[:main] = GFit.Polynomial(2, 0.5, 1)\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html#Gaussian","page":"Built-in components","title":"Gaussian","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"A normalized Gaussian component for 1D and 2D domains.","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"1D: GFit.Components.Gaussian(norm, center, sigma);\n2D: GFit.Components.Gaussian(norm, centerX, centerY, sigma) (implies sigmaX=sigmaY, angle=0);\n2D: GFit.Components.Gaussian(norm, centerX, centerY, sigmaX, sigmaY, angle);","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"1D:\nnorm::Parameter: the area below the Gaussian function;\ncenter::Parameter: the location of the center of the Gaussian;\nsigma::Parameter: the width the Gaussian;\n2D:\nnorm::Parameter: the volume below the Gaussian function;\ncenterX::Parameter: the X coordinate of the center of the Gaussian;\ncenterY::Parameter: the Y coordinate of the center of the Gaussian;\nsigmaX::Parameter: the width the Gaussian along the X direction (when angle=0);\nsigmaY::Parameter: the width the Gaussian along the Y direction (when angle=0);\nangle::Parameter: the rotation angle (in degrees) of the Gaussian.","category":"page"},{"location":"builtincomp.html#Examples-4","page":"Built-in components","title":"Examples","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using GFit\n\n# Prepare domain and model\ndom = Domain(1:0.5:5)\nmodel = Model(dom, GFit.Gaussian(1, 3, 0.5))\n\n# Fit model against data\ndata = Measures(dom, [0, 0.3, 6.2, 25.4, 37.6, 23., 7.1, 0.4, 0], 0.6)\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"A very common problem is to fit the histogram of a distribution with a Gaussian model. In the following example we will generate such distribution with Random.randn, and use the Gnuplot.jl package to calculate the histogram and display the plot:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using Random, GFit, Gnuplot\n\n# Calculate histogram of the distribution\nhh = hist(randn(10000), bs=0.25)\n\n# Prepare domain and data and fit a model\ndom = Domain(hh.bins)\ndata = Measures(dom, hh.counts, 1.)\nmodel = Model(dom, GFit.Gaussian(1e3, 0, 1))\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"@gp hh coords(dom) model() \"w l t 'Model' lw 3\"\nsaveas(\"gaussian\") # hide","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"(Image: )","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"A similar problem in 2D can be handled as follows:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using Random, GFit, Gnuplot\n\n# Calculate histogram of the distribution\nhh = hist(1 .+ randn(10000), 2 .* randn(10000))\n\n# Prepare domain and data and fit a model\ndom = CartesianDomain(hh.bins1, hh.bins2)\ndata = Measures(dom, hh.counts, 1.)\nmodel = Model(dom, GFit.Gaussian(1e3, 0, 0, 1, 1, 0))\nres = fit!(model, data)","category":"page"},{"location":"builtincomp.html#SumReducer","page":"Built-in components","title":"SumReducer","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"A component calculating the element-wise sum of a (potentially large) number of other components.","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The SumReducer constructor is defined as follows:","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"SumReducer(args::AbstractSet{Symbol})\nSumReducer(args::Vector{Symbol})\nSumReducer(args::Vararg{Symbol})","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"where the Symbols represent the component names","category":"page"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"The SumReducer component has no parameter.","category":"page"},{"location":"builtincomp.html#Example","page":"Built-in components","title":"Example","text":"","category":"section"},{"location":"builtincomp.html","page":"Built-in components","title":"Built-in components","text":"using GFit\n\n# Prepare domain and a linear model (with initial guess parameters)\ndom = Domain(1:5)\nmodel = Model(dom, :linear => @λ (x, b=2, m=0.5) -> (b .+ x .* m))\n\n# Add a quadratic component to the model\nmodel[:quadratic] = @λ (x, p2=1) -> (p2 .* x.^2)\n\n# The total model is the sum of `linear` and `quadratic`\nmodel[:main] = SumReducer(:linear, :quadratic)\n\n# Fit model against data\ndata = Measures(dom, [4.01, 7.58, 12.13, 19.78, 29.04], 0.4)\nres = fit!(model, data)","category":"page"},{"location":"viewers.html#Viewers","page":"Viewers","title":"Viewers","text":"","category":"section"},{"location":"concepts.html#Basic-concepts-and-data-types","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"","category":"section"},{"location":"concepts.html","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"In order to exploit the GFit.jl model expressiveness we need to introduce a few concepts, and the associated data types:","category":"page"},{"location":"concepts.html","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Domain: an N-dimensional grid of points where the model is to be evaluated, it is analogous to the independent varible vecx in the f(vecx) notation. It is represented by either:\na Domain{N} object for linear domains, i.e. where the coordinates for each of the N dimensions are explicitly specified for all the points;\nor a CartesianDomain{N} object where the coordinates are specified for each of the N axis and the coordinates for all points are obtained as the cartesian product of all the axes.  A cartesian domain is internally transformed into a linear one when needed;\nA domain object (either linear or cartesian) is required as first argument for the Model and Measures constructors (see below).\nMeasures: a container for the N-dimensional empirical data and their associated 1sigma Gaussian uncertainties, represented by an object of type Measures{N} (further options may be available in the future, such as Poisson counts);\nModel component: the atomic building block of a (potentially very complex) model, it is essentially a function used to map a Domain or CartesianDomain object into a Vector{Float64} representing the component evaluation.  A component is a structure inheriting from GFit.AbstractComponent and is typically characterized by one or more parameters (see below). One component's evaluation can also be used as input for another one's calculation, thus inducing a dependency between the two.  The GFit.jl package provides several Built-in components, and new ones can be implemented by the user.  The memoization mechanism operates at the component level and aims to avoid unnecessary re-evaluation of the component if none of its parameter values has changed since last evaluation;\nParameter: a single floating point number characterizing a specific aspect for the evaluation of a component (e.g. the slope of a power law or the width of a Gaussian profile). The parameter values are automatically varied during the fitting process until the residuals between the global model evaluation and the empirical data are minimized.  A parameter can be fixed to a specific value, limited in an interval, and/or be dynamically calculated (patched) according to the values of other parameters.  All parameters are represented by an object of type GFit.Parameter;\nModel: is the overall model description, whose evaluation is supposed to be compared to a single Measures objects and whose parameters are varied during fitting to reduce the residuals. All models are represented by an object of type Model containing a single Domain or CartesianDomain object representing the domain where the model will be evaluated, and one or more components characterizing the model itself.  Each component is identified by a unique name (actually a Symbol) within a model.\nComponent dependencies and main component: the evaluation of a component, say A, may use the output of another component, say B, to calculate its output.  In this case we say that A depends on B, and therefore B needs to be evaluated before A (circular dependencies are not allowed, and would raise an error if attempted).  The dependencies are automatically identified, and the last component being evaluated is dubbed main component since its output represent the overall model evaluation;\nMulti-model: a container for two or more models, suitable to be compared to a corresponding number of Measures objects to perform Multi-dataset fitting.  All models are identified by a unique integer identifier, starting from 1.  A multi-model is represented by an object of type MultiModel;\nFit results: the purpose of fitting is to minimize the distance between the model and the data, as quantified by a proper fit statistic (typically a reduced chi^2 for the Gaussian uncertainties case). Such statistic, as well as other information concerning the fit and the best fit parameter values and uncertainties, are returned by the fit!() function in a GFit.FitResult structure.\nλ-function: is an anonymous function used in two different contexts within GFit.jl:\nto calculate the value of a Parameter as a function of other Parameter's values. In this case the parameters are said to be patched, or linked, since there is a constraint between their values.  Two (or more) parameters may be patched within the same model, or across models in a multi-model analysis;\nto define a model component using a standard Julia mathematical expression involving Parameters values or other components.\nIn both cases the λ-function is generated using the @λ macro and the standard Julia syntax for anonymous functions.\nMinimizer: the GFit.jl package provides just the tools to define and manipulate a model, but the actual fitting (namely, the minimization of the residuals) is performed by an external minimizer library.  Two minimizers are currently available:\nLsqFit: a pure-Julia minimizer;\nCMPFit: a C minimizer wrapped in a Julia package.\nBoth are automatically installed with GFit.jl, and LsqFit is the default choice (unless otherwise specified in the fit!() function call).  However, for some of the most complex cases CMPFit seems to be more robust and less sensitive to initial guess parameters.\nMock data: evaluating a a model may be useful even before actual data are available, e.g. to test its robustness and capabilities.  To this purpose GFit.jl provides the GFit.mock() function which is able to generate mock data set(s) using a (multi-)model as ground truth, and add a random noise to simulate the measurement process. This functionality is used in all the examples presented in the next sections.","category":"page"},{"location":"concepts.html#How-to-access-the-data-structures","page":"Basic concepts and data types","title":"How to access the data structures","text":"","category":"section"},{"location":"concepts.html","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Many of the above mentioned data structures are accessible using indexing (as in dictionary or vectors) or a struct-like interface, starting from a single Model or a MultiModel object.  Hence it is important to keep in mind the relationships among these objects to be able to access them:","category":"page"},{"location":"concepts.html","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Multi-model (`multi`)\n |\n + -- Model 1 (`model`)\n |     |\n |     + -- Component1\n |     |     |\n |     |     + -- Param1\n |     |     + -- Param2\n |     |     + -- ...\n |     + -- Component2\n |     + -- etc.\n + -- Model 2\n + -- ...","category":"page"},{"location":"concepts.html","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"E.g. the syntax to access the value of a parameter in a single model case is: model[:Component1].Param1.val.  In a multi-model case it is: multi[1][:Component1].Param1.val.","category":"page"},{"location":"misc.html#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc.html#Save-a-snapshot","page":"Miscellaneous","title":"Save a snapshot","text":"","category":"section"},{"location":"misc.html#Generate-mock-datasets","page":"Miscellaneous","title":"Generate mock datasets","text":"","category":"section"},{"location":"minimizers.html#Minimizers","page":"Minimizers","title":"Minimizers","text":"","category":"section"},{"location":"customcomp.html#Custom-components","page":"Custom components","title":"Custom components","text":"","category":"section"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"Besides the Built-in components, the user may define any number of custom components to be used in a model.","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"A user-defined component shall satisfy the following constraints:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"it shall be defined as a structure inheriting AbstractComponent;\nthe structure fields shall contain the component parameters as Parameter object(s), e.g.:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"struct MyComponent <: AbstractComponent\n\tparam1::Parameter\n\tparam2::Parameter\n\t...\nend","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"(see below for a complete example). Alternatively, the parameters may be present in a single field of type OrderedDict{Symbol, Parameter} (see the Polynomial component for an example);","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"the evaluate! function shall be extended to provide the component-specific code for evaluation.","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"Specifically, the evaluate! function should replace the content of a buffer::Vector{Float64} with the outcome of the new component evaluation, given the numerical values for the parameters, e.g.","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"function evaluate!(buffer::Vector{Float64}, comp::MyComponent, x::AbstractDomain,\n                   param1::Float64, param2::Float64...)\n\tbuffer .= (component evaluation using param1 and param2 values)\nend","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"Optionally, the user may chose to extend also the following functions:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"prepare!: to prepare the component for evaluations on a specific domain (e.g. to pre-compute quantities which depend only on the domain being used). The return value must be the buffer (of type Vector{Float64}) to accomodate the component evaluation.  The default implementation simply creates a buffer with the same length as the input domain;\ndependencies: return a Vector{Symbol} specifying the names of the component dependencies.  The evaluation of the latter will be made available as arguments to the evaluate! method. The default implementation returns an empty list Symbol[].","category":"page"},{"location":"customcomp.html#Life-cycle-of-a-component","page":"Custom components","title":"Life cycle of a component","text":"","category":"section"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"All components \"live\" within Model object, which has a well defined domain associated (see constructor of Model).  The same domain will also be used for component evaluations.  The typical life cycle of a component is as follows:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"the component is created invoking its constructor and providing an initial guess values for all parameters;\nthe component is added to the model. In this step the prepare! function is called to precompute component quantities (according to the domain associated to the Model object) and to allocate the buffer for evaluations.  Note that the prepare! function is invoked only once for each component;\nthe user may optionally modify the component parameter guess values, as well as their Parameter constraints, before starting the fit;\nbefore starting the fit process a dependency tree is generated to identify all component dependencies (by invoking the dependencies() function for all components). The tree is used to identify the proper order for component evaluations: leaves will be evaluated first, and the remaining ones following the tree branches.  The evaluation of the last component (the root of the tree) will be compared to the data;\nduring the fitting process the component evaluate! function is invoked whenever the minimizer change one of its parameter values, until a convergence criterion is satisfied.","category":"page"},{"location":"customcomp.html#Example","page":"Custom components","title":"Example","text":"","category":"section"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"A common case is to compare empirical data with a numerically evaluated theoretical model, possibly defined on a different grid with respect to the empirical one.  An interpolation is therefore required in order to compare the model to the data.","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"Let's assume the theoretical model is defined as follows:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"theory_x = 0.:10\ntheory_y = [0, 0.841, 0.909, 0.141, -0.757, -0.959, -0.279, 0.657, 0.989, 0.412, -0.544]\nprintln() # hide","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"while the empirical data are:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"obs_x = [0.500, 2.071, 3.642, 5.212, 6.783, 8.354, 9.925]\nobs_y = [2.048, 3.481, 1.060, 0.515, 3.220, 4.398, 1.808]\nprintln() # hide","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"The following example shows how to implement a component aimed to interpolate the theoretical model onto a specific empirical domain, with the only parameter being a global scaling factor:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"using GFit, Interpolations\nimport GFit.prepare!, GFit.evaluate!\n\n# Define the component structure and constructor\nstruct Interpolator <: GFit.AbstractComponent\n\ttheory_x::Vector{Float64}\n\ttheory_y::Vector{Float64}\n\tinterp_y::Vector{Float64}  # will contain the interpolated values\n\tscale::GFit.Parameter\n\n\tfunction Interpolator(theory_x, theory_y)\n\t\tscale = GFit.Parameter(1)\n\t\tscale.low = 0                  # ensure scale parameter is positive\n\t\tinterp_y = Vector{Float64}()   # this will be populated in prepare!()\n\t\treturn new(theory_x, theory_y, interp_y, scale)\n\tend\nend\n\n# Component preparation: invoked only once to precompute quantities\n# and allocate evaluation buffer\nfunction prepare!(comp::Interpolator, domain::AbstractDomain{1})\n\t# Pre-compute interpolation on the empirical domain\n\titp = linear_interpolation(comp.theory_x, comp.theory_y)\n\tappend!(comp.interp_y, itp(coords(domain)))\n\treturn fill(NaN, length(comp.interp_y)) # buffer for evaluations\nend\n\n# Component evaluation\nfunction evaluate!(buffer::Vector{Float64}, comp::Interpolator, domain::AbstractDomain{1},\n                   scale)\n\tbuffer .= scale .* comp.interp_y\nend\nprintln() # hide","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"The following code shows how to prepare a Model including the interpolated theoretical model, and to take into account the possible background introduced by the detector used to obtain empirical data:","category":"page"},{"location":"customcomp.html","page":"Custom components","title":"Custom components","text":"dom = Domain(obs_x)\nmodel = Model(dom, :theory => Interpolator(theory_x, theory_y),\n                   :background => GFit.OffsetSlope(1., 0., 0.2),\n                   :main => SumReducer(:theory, :background))\ndata = Measures(dom, obs_y, 0.2)\nres = fit!(model, data)","category":"page"},{"location":"multifit.html#Multi-dataset-fitting","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"","category":"section"},{"location":"multifit.html","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"GFit.jl is able to simultaneously fit several models against a corresponding number of datasets, while placing constraints among the models. Typical use cases are:","category":"page"},{"location":"multifit.html","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"a single phenomenon is observed with two (or more) instruments/detectors;\na single phenomenon is observed at different times;","category":"page"},{"location":"multifit.html","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"Fitting multiple datasets simultaneously may provide tighter constraints on the best fit parameters under the assumption that the models are somehow related, i.e. that their parameters are constrained (or patched).","category":"page"},{"location":"multifit.html","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"To perform a multi-dataset fitting we should create one Model for each dataset in the usual way, collect them in a MultiModel object, and define patch constraints among models.   The following example shows how to fit two Gaussian curves under the hypotesis that the center and normalization parameters are the same:","category":"page"},{"location":"multifit.html","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"using GFit\n\n# Create domain, individual models and the MultiModel container\ndom = Domain(-5.:5)\nmodel1 = Model(dom, GFit.Gaussian(1, 0., 1.))\nmodel2 = Model(dom, GFit.Gaussian(1, 0., 1.))\nmulti = MultiModel(model1, model2)\n\n# Patch parameters\nmulti[2][:main].norm.mpatch   = @λ m -> m[1][:main].norm\nmulti[2][:main].center.mpatch = @λ m -> m[1][:main].center\n\n# Create datasets and fit\ndata1 = Measures(dom, [-0.006,  0.015,  0.001,  0.049,  0.198,  0.430,  0.226,  0.048,  0.017, -0.001, -0.006], 0.04)\ndata2 = Measures(dom, [-0.072, -0.033, -0.070,  0.108,  0.168,  0.765,  0.113, -0.054,  0.032,  0.013,  0.015], 0.04)\nres = fit!(multi, [data1, data2])","category":"page"},{"location":"multifit.html","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"The MultiModel object is very similar to a vector, hence the inidividual models can be retrieved by a numeric index, as in multi[2][:main].norm.  Also, the bestfit values can be retrieved by indexing the bestfit field of the results, e.g.:","category":"page"},{"location":"multifit.html","page":"Multi-dataset fitting","title":"Multi-dataset fitting","text":"println(\"Width of Gaussian 1: \", res.bestfit[1][:main].sigma.val, \" ± \", res.bestfit[1][:main].sigma.unc, \"\\n\")\nprintln(\"Width of Gaussian 2: \", res.bestfit[2][:main].sigma.val, \" ± \", res.bestfit[2][:main].sigma.unc, \"\\n\")\nprintln(\"Reduced χ^2: \", res.fitstat)","category":"page"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"","category":"page"},{"location":"api.html#Exported-symbols","page":"API","title":"Exported symbols","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"The list of GFit.jl exported symbols is as follows:","category":"page"},{"location":"api.html","page":"API","title":"API","text":"CartesianDomain{N}\nDomain{N}\nMeasures{N}\nModel\nMultiModel\n@λ\naxis\ncoords\ndomain\nevaluate\nfit!\nfreeze!\ngetindex\nhaskey\nisfreezed\nlength\npush!\nselect_maincomp!\nthaw!\nuncerts\nvalues","category":"page"},{"location":"api.html#GFit.CartesianDomain","page":"API","title":"GFit.CartesianDomain","text":"CartesianDomain{N}\n\nAn object representing a model, or a dataset, N-dimensional cartesian domain (i.e. a grid).\n\nAvailable constructors:\n\nDomain(axis...): each argument is a vector containing the coordinates on a given axis (arguments may have different lengths);\nDomain(lengths...): returns a N-dim CartesianDomain object whose axis lengths are specified in the arguments.\n\nNote that a CartesianDomain requires at least 2 dimensions.\n\nCoordinates for all points along a given axis can be obtained with the coords() function, while the coordinates of the grid can be obtained with axis().\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.Domain","page":"API","title":"GFit.Domain","text":"Domain{N}\n\nAn object representing a model, or a dataset, N-dimensional linear domain.\n\nAvailable constructors:\n\nDomain(coords...): each argument is a vector, one for each dimension (all arguments must have same lengths);\nDomain(length): returns a 1-dim Domain object of the given length.\n\nCoordinates for all points along a given axis can be obtained with the coords function.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.Measures","page":"API","title":"GFit.Measures","text":"Measures{N}\n\nAn object representing a set of empirical measurements (with Gaussian uncertainties)\n\nAvailable constructors:\n\nMeasures(domain::Domain{N},           values::AbstractVector{T},           uncerts::AbstractVector{T}) where {T <: AbstractFloat, N}\nMeasures(domain::CartesianDomain{N},           values::AbstractArray{T, N},           uncerts::AbstractArray{T, N}) where {T <: AbstractFloat, N}\n\nIn the above constructor methods the last argument may also be a scalar value, to set the same uncertainty for all the measurements. The method accepting a CartesianDomain requires arrays with at least 2 dimensions.\n\nThe domain, values and uncertainties for a Measures object can be retrieved using the domain, values and uncerts functions respectively.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.Model","page":"API","title":"GFit.Model","text":"Model\n\nA structure containing a model description, whose evaluation is suitable to be compared to a single empirical dataset.\n\nConstructor is: Model(domain::AbstractDomain, components...) where the first argument is either a Domain or CartesianDomain object, and the remaining one(s) is (are) the model component(s), which may be given as:\n\na single Dict{Symbol, AbstractComponent}, where the keys are the names and the values the component objects;\na single component, which will have a default name is assigned (:main);\na single λFunct, which will be wrapped into an LComp component and a default name will be assigned (:main);\none or more Pair{Symbol, AbstractComponent}, where the first element is the name and the second is the component.\n\nYou may access the individual component in a Model using the indexing syntax, as if it was a Dict{Symbol, AbstractComponent}.  Also, you may add new components to a Model after it has been created using the same synatx.  Finally, you may use the keys() and haskey() functions with their usual meanings.\n\nIndividual components may be freezed (i.e. have all its parameters fixed during fitting, despite the individual Parameter settings) or thawed using the freeze!() and thaw!() functions.  Use the isfreezed() function to check if a component is freezed.\n\nThe main component, i.e. the one whose evaluation corresponds to the overall model evaluation, is typically automatically identified by analyzing the component dependencies.  However a specific component may be forced to be the main one by invoking select_maincomp!.\n\nThe model is automatically evaluated whenever needed, however there are a few cases where it is not possible to trigger an automatic evaluation, e.g. immediately after the user modifies a Parameter value. In this case an evaluation can be forced by invoking evaluate().\n\nThe most important function for a Model object is fit!(), which allows to fit the model against an empirical dataset. The ! in the name reminds us that, after fitting, the parameter values will be set to the best fit ones (rather than retaining their original values).\n\nThe model and all component evaluation can be obtained by using the Model object has if it was a function: with no arguments it will return the main component evaluation, while if a Symbol is given as argument it will return the evaluation of the component with the same name.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.MultiModel","page":"API","title":"GFit.MultiModel","text":"MultiModel\n\nA structure containing a multi-model description, whose evaluation is suitable to be compared to a set of empirical datasets. A MultiModel is very similar to a vector of Model objects, with the ability to trasparently handle the patch constraints between one model and the other.\n\nConstructor is: MultiModel(model1, model2, ...).\n\nYou may access the individual Model objects the indexing syntax, as if it was a Vector{Model}.  Also, you may add new model to a MultiModel after it has been created using the push!() function. Finally, you may retrieve the length of the vector with length().\n\nJust like a Model object you may need to manually trigger a MultiModel evaluation using the evaluate() function.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.@λ","page":"API","title":"GFit.@λ","text":"@λ expr\n\nMacro to generate λFunct objects using the same syntax as in a standard Julia anonymous function. Example: @λ (x, f) -> f .* x\n\n\n\n\n\n","category":"macro"},{"location":"api.html#GFit.axis","page":"API","title":"GFit.axis","text":"axis(d::CartesianDomain, dim::Integer)\n\nReturns the coordinates of the grid along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.coords","page":"API","title":"GFit.coords","text":"coords(d::Domain{1})\ncoords(d::Domain, dim::Integer)\ncoords(d::CartesianDomain, dim::Integer)\n\nReturns coordinates of all points along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.domain","page":"API","title":"GFit.domain","text":"domain(model::Model)\n\nReturn the domain where the model is evaluated.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.evaluate","page":"API","title":"GFit.evaluate","text":"evaluate(model::Model)\n\nEvaluate a Model and update internal structures.\n\n\n\n\n\nevaluate(multi::MultiModel)\n\nEvaluate a MultiModel and update internal structures.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.fit!","page":"API","title":"GFit.fit!","text":"fit!(model::Model, data::Measures; minimizer::AbstractMinimizer=lsqfit())\n\nFit a model to an empirical data set using the specified minimizer (default: lsqfit()).\n\n\n\n\n\nfit!(multi::MultiModel, data::Vector{Measures{N}}; minimizer::AbstractMinimizer=lsqfit())\n\nFit a multi-model to a set of empirical data sets using the specified minimizer (default: lsqfit()).\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.freeze!","page":"API","title":"GFit.freeze!","text":"freeze!(model::Model, cname::Symbol)\n\nFreeze a component in the model (i.e. treat all component parameters as fixed for fitting).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.getindex","page":"API","title":"Base.getindex","text":"getindex(d::Union{Domain, CartesianDomain}, dim::Integer)\n\nShortcut for coords(d, dim).\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.haskey","page":"API","title":"Base.haskey","text":"haskey(m::Model, name::Symbol)\n\nCheck whether a component exists in model.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.isfreezed","page":"API","title":"GFit.isfreezed","text":"isfreezed(model::Model, cname::Symbol)\n\nCheck whether a component is freezed in the model.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.length","page":"API","title":"Base.length","text":"length(multi::MultiModel)\n\nReturns how many Model objects are contained in a MultiModel.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.push!","page":"API","title":"Base.push!","text":"push!(multi::MultiModel, model::Model)\n\nPush a new Model object into a MultiModel.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.select_maincomp!","page":"API","title":"GFit.select_maincomp!","text":"select_maincomp!(model::Model, cname::Symbol)\n\nForce a component to be the final one for model evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.thaw!","page":"API","title":"GFit.thaw!","text":"thaw!(model::Model, cname::Symbol)\n\nThaw a freezed component in the model (i.e. treat component parameters as fixed only if explicitly set in the corresponding Parameter structure).\n\n\n\n\n\n","category":"function"},{"location":"api.html#GFit.uncerts","page":"API","title":"GFit.uncerts","text":"uncerts(d::Measures)\n\nReturns the measurement uncertainties as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.values","page":"API","title":"Base.values","text":"values(d::Measures)\n\nReturns the measurement values as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Non-exported-symbols","page":"API","title":"Non-exported symbols","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"The following symbols are not exported by the GFit.jl package since they are typically not used in every day work, or aimed to debugging purposes.  Still, they can be useful in some case, hence they are documented here.","category":"page"},{"location":"api.html","page":"API","title":"API","text":"GFit.FitResult\nGFit.λFunct\nGFit.Parameter\nGFit.mock","category":"page"},{"location":"api.html#GFit.FitResult","page":"API","title":"GFit.FitResult","text":"FitResult\n\nA structure representing the results of a fitting process.\n\nFields:\n\ntimestamp::DateTime: time at which the fitting process has started;\nelapsed::Float64: elapsed time (in seconds);\nndata::Int: number of data empirical points;\nnfree::Int: number of free parameters;\ndof::Int: ndata - nfree;\nfitstat::Float64: fit statistics (equivalent ro reduced χ^2 for Measures objects);\nstatus: minimizer exit status (tells whether convergence criterion has been satisfied, or if an error has occurred during fitting);\nbestfit: dictionary of Parameter objects containing best fit values and their 1-σ uncertainties.  In the multi-model case this will be a vector of dictionaries.\n\nNote: the FitResult fields are supposed to be accessed directly by the user, without invoking any get/set method.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.λFunct","page":"API","title":"GFit.λFunct","text":"λFunct\n\nA representation for a λ function, containing a reference to the function itself, a string representation of its source code (for displaying purposes) and a list of its arguments.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.Parameter","page":"API","title":"GFit.Parameter","text":"Parameter\n\nA structure representing a model parameter.\n\nFields:\n\nval::Float64: parameter value (initial guess before fitting, or best fit one after fitting);\nlow::Float64: lower limit for the value (default: -Inf);\nhigh::Float64: upper limit for the value (default: +Inf);\nfixed::Bool: whether the parameter is fixed during fitting (default: false);\npatch::Union{Nothing, Symbol, λFunct}: patch prescription within the same model;\nmpatch::Union{Nothing, λFunct}: patch prescription in a multi-model analysis;\nactual::Float64: actual value for the parameter (i.e. after applying the patch prescription)`;\nunc::Float64: 1σ uncertainty associated to the parameter value.\n\nNote: the Parameter fields are supposed to be accessed directly by the user, without invoking any get/set method.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GFit.mock","page":"API","title":"GFit.mock","text":"mock(::Type{Measures}, model::Model; keywords...)\nmock(::Type{Measures}, multi::MultiModel; keywords...)\n\nGenerate mock dataset(s) using a ground truth Model or MultiModel object. The first version returns a single Measures object, while the second returns a Vector{Measures}.\n\nThe measurement random errors added to the data points are drawn from a Normal distribution centered on the data value itself, and a width given by the sum of three contributions:\n\nproportional part: error proportional to each data point value;\nrange part: error proportional to the range spanned by all values in a single dataset;\nabsolute part: absolute error value.\n\nNo systematic error is considered when generating mock dataset(s).\n\nAccepted keywords:\n\nproperr=0.01: proportional error;\nrangeerr=0.05: range error;\nabserr=0.: absolute error;\nseed=nothing: seed for the Random.MersenneTwister generator.\n\n\n\n\n\n","category":"function"},{"location":"examples.html#Examples:","page":"Examples","title":"Examples:","text":"","category":"section"},{"location":"examples.html#D:-offset-two-Gaussian-profiles","page":"Examples","title":"1D: offset + two Gaussian profiles","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"x = Domain(1:0.05:10)\nmodel = Model(x,\n    :offset => 4,\n    :line1  => GFit.Gaussian(1.1 , 4.4, 0.51),\n    :line2  => GFit.Gaussian(0.52, 5.5, 1.2 ))\n\nusing Random\nrng = MersenneTwister(0);\nnoise = maximum(model()) * 0.01\ndata = Measures(model() + noise * randn(rng, length(model())), noise);\nret1 = fit!(model, data)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To produce the plots I will use the Gnuplot.jl package, but the user can choose any other package:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Gnuplot\n@gp    \"set multi layout 2,1\" :-\n@gp :- domain(model) data.val data.unc \"w yerr tit 'Data'\" :-\n@gp :- domain(model) model(:line1) .+ model(:offset) \"w l tit 'offset + line1'\" :-\n@gp :- domain(model) model(:line2) .+ model(:offset) \"w l tit 'offset + line2'\" :-\n@gp :- domain(model) model() \"w lines tit 'Model' lw 3\" :-\n@gp :- 2 x[1] (data.val - model()) ./ data.unc fill(1., length(data)) \"w yerr tit 'Residuals'\"","category":"page"},{"location":"examples.html#D:-tilted-plane-2D-Gaussian-profile","page":"Examples","title":"2D: tilted plane + 2D Gaussian profile","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"dom = CartesianDomain(-5:0.1:5, -4:0.1:4)\nmodel = Model(dom,\n              :background => GFit.OffsetSlope(0, 0, 0., 2., 3.),\n              :psf => GFit.Gaussian(100., 0., 0., 1, 0.3, 15), \n\t\t\t  :main => SumReducer(:background, :psf))\ndata = GFit.mock(Measures, model)\nret1 = fit!(model, data)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To produce the plots I will use the Gnuplot.jl package, but the user can choose any other package:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Gnuplot\n\n# Plot the model...\n@gsp coords(dom, 1) coords(dom, 2) model()\n\n# ...and the residuals\n@gsp coords(dom, 1) coords(dom, 2) values(data) - model()\n\n# Plot using pm3d style\n@gsp \"set pm3d\" \"set palette\" coords(dom, 1) coords(dom, 2) model() \"w dots\"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using GFit, Gnuplot\nGnuplot.quitall()\nsaveas(file) = Gnuplot.save(term=\"pngcairo size 550,350 fontscale 0.8\", output=\"assets/$(file).png\")","category":"page"},{"location":"index.html#Gfit.jl","page":"Home","title":"Gfit.jl","text":"","category":"section"},{"location":"index.html#A-model-fitting-framework-for-Julia.","page":"Home","title":"A model fitting framework for Julia.","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: Stars)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Gfit.jl is a general purpose, data-driven model fitting framework for Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It provides the basic tools to define, interactively manipulate and efficiently evaluate a (possibly very complex) model, and to fit the latter to empirical data. The main functionalities are:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"it handles datasets of any dimensionality;\nthe syntax is very simple and concise as it resembles the indexing for dictionaries and the field access for structs.  The most relevant functions are the self-explanatory fit!() and the object constructors (see Basic concepts and data types);\nthe fitting model is evaluated on a user defined domain, and is the result of a combination of model components or mathematical expressions (in the form of lambda functions), or any arbitrary mixture of the two;\nit provides several ready-to-use Built-in components, and it also allows to define new components to suit specific needs (Custom components);\nall components results are cached so that repeated evaluations with the same parameter values do not involve further calculations (memoization);\nmodel parameters can be fixed to a specific value, limited in an interval, and/or be dynamically linked (patched) to the values of other parameters (see Parameter constraints);\nmultiple data sets can be fitted simultaneously against different models whose parameters can be patched (see Multi-dataset fitting);\nit support different minimizers (LsqFit and CMPFit), both aimed to carry out non-linear least squares minimization (see Minimizers);\nit provides several facilities for interactive fitting and result displaying (see Viewers).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The fitting process involves the automatic variation of the parameter values, subject to the user defined constraints, until the differences between the evaluated model and the empirical data are minimized. The implementation details depends on the chosen minimizer.  The purpose of Gfit.jl is thus to act as an interface between the high-level model definition and manipulation (facing the user), and the low-level implementation details (facing the minimizer).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the main purpose of GFit.jl is to allow easy manipulation of complex models, and that there may be little advantage in using it for a simple linear regression or for models involving just a single parameter, although it is definitely possible to use it also in these cases.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"In the Julia REPL type:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add GFit","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The ] character starts the Julia package manager. Hit backspace key to return to Julia prompt.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In order to easily visualize the outcomes of 1D analysis you may be interested in installing also GFitViewer and/or Gnuplot.jl:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add GFitViewer\njulia> ]add Gnuplot","category":"page"},{"location":"index.html#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The typical workflow to use GFit.jl is as follows:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Wrap empirical data domain and measures into one (ore more) Domain and Measures object(s);\nCreate a Model object and build it by adding components or mathematical expressions, each representing a specific aspect of the theoretical model;\nOptionally set initial guess parameter values, define constraints between model parameters, etc.;\nFit the model against the data and inspect the results;\nIf needed, modify the model and repeat the fitting process;\nExploit the results and outputs.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A very simple example showing the above workflow is:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using GFit\n\n# Prepare vectors with domain points, empirical measures and their uncertainties\nx    = [0.1, 1.1, 2.1, 3.1, 4.1]\nmeas = [6.29, 7.27, 10.41, 18.67, 25.3]\nunc  = [1.1, 1.1, 1.1, 1.2, 1.2]\n\n# Prepare GFit input objects\ndom  = Domain(x)\ndata = Measures(dom, meas, unc)\n\n# Create a model using an explicit mathematical expression, and provide the\n# initial guess values:\nmodel = Model(dom, @λ (x, a2=1, a1=1, a0=5) -> (a2 .* x.^2  .+  a1 .* x  .+  a0))\n\n# Fit model to the data\nres = fit!(model, data)\nnothing # hide","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The GFit.jl package implements a show method for many of the data types involved, hence the above code results in the following output:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"show(res) # hide","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"showing the best fit parameter values and the associated uncertaintites, as well as a few statistics concerning the fitting process.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If not saitisfied with the result you may, for instance, change the initial value for a parameter and re-run the fit:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"model[:main].a0.val = 5\nres = fit!(model, data)\nnothing # hide","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Once done, you may plot the data and the best fit model with a plotting framework of your choice. E.g., with Gnuplot.jl:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Gnuplot\n@gp coords(dom) values(data) uncerts(data) \"w yerr t 'Data'\" :-\n@gp :- coords(dom) model() \"w l t 'Best fit model'\"\nsaveas(\"simple_example\") # hide","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Also, you can easily access the numerical results for further analysis, e.g.:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"println(\"Best fit value for the offset parameter: \", \n\tres.bestfit[:main].a0.val, \" ± \", \n\tres.bestfit[:main].a0.unc, \"\\n\",\n\t\"Reduced χ^2: \", res.fitstat)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The above example is definitely a simple one, but even more complex ones follow essentially the same workflow.","category":"page"}]
}
