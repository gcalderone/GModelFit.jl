var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Exported-symbols","page":"API","title":"Exported symbols","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The list of GFit.jl exported symbols is as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"CartesianDomain{N}\nDomain{N}\nMeasures{N}\nModel\nMultiModel\n@λ\naxis\ncoords\ndomain\nevaluate\nfit!\nfreeze!\ngetindex\nhaskey\nisfreezed\nlength\npush!\nselect_maincomp!\nthaw!\nuncerts\nvalues","category":"page"},{"location":"api/#GFit.CartesianDomain","page":"API","title":"GFit.CartesianDomain","text":"CartesianDomain{N}\n\nAn object representing a model, or a dataset, N-dimensional cartesian domain (i.e. a grid).\n\nAvailable constructors:\n\nDomain(axis...): each argument is a vector containing the coordinates on a given axis (arguments may have different lengths);\nDomain(lengths...): returns a N-dim CartesianDomain object whose axis lengths are specified in the arguments.\n\nNote that a CartesianDomain requires at least 2 dimensions.\n\nCoordinates for all points along a given axis can be obtained with the coords() function, while the coordinates of the grid can be obtained with axis().\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.Domain","page":"API","title":"GFit.Domain","text":"Domain{N}\n\nAn object representing a model, or a dataset, N-dimensional linear domain.\n\nAvailable constructors:\n\nDomain(coords...): each argument is a vector, one for each dimension (all arguments must have same lengths);\nDomain(length): returns a 1-dim Domain object of the given length.\n\nCoordinates for all points along a given axis can be obtained with the coords function.\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.Measures","page":"API","title":"GFit.Measures","text":"Measures{N}\n\nAn object representing a set of empirical measurements (with Gaussian uncertainties)\n\nAvailable constructors:\n\nMeasures(domain::Domain{N},           values::AbstractVector{T},           uncerts::AbstractVector{T}) where {T <: AbstractFloat, N}\nMeasures(domain::CartesianDomain{N},           values::AbstractArray{T, N},           uncerts::AbstractArray{T, N}) where {T <: AbstractFloat, N}\n\nIn the above constructor methods the last argument may also be a scalar value, to set the same uncertainty for all the measurements. The method accepting a CartesianDomain requires arrays with at least 2 dimensions.\n\nThe domain, values and uncertainties for a Measures object can be retrieved using the domain, values and uncerts functions respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.Model","page":"API","title":"GFit.Model","text":"Model\n\nA structure containing a model description, whose evaluation is suitable to be compared to a single empirical dataset.\n\nConstructor is: Model(domain::AbstractDomain, components...) where the first argument is either a Domain or CartesianDomain object, and the remaining one(s) is (are) the model component(s), which may be given as:\n\na single Dict{Symbol, AbstractComponent}, where the keys are the names and the values the component objects;\na single component, which will have a default name is assigned (:main);\na single λFunct, which will be wrapped into an LComp component and a default name will be assigned (:main);\none or more Pair{Symbol, AbstractComponent}, where the first element is the name and the second is the component.\n\nYou may access the individual component in a Model using the indexing syntax, as if it was a Dict{Symbol, AbstractComponent}.  Also, you may add new components to a Model after it has been created using the same synatx.  Finally, you may use the keys() and haskey() functions with their usual meanings.\n\nIndividual components may be freezed (i.e. have all its parameters fixed during fitting, despite the individual Parameter settings) or thawed using the freeze!() and thaw!() functions.  Use the isfreezed() function to check if a component is freezed.\n\nThe main component, i.e. the one whose evaluation corresponds to the overall model evaluation, is typically automatically identified by analyzing the component dependencies.  However a specific component may be forced to be the main one by invoking select_maincomp!.\n\nThe model is automatically evaluated whenever needed, however there are a few cases where it is not possible to trigger an automatic evaluation, e.g. immediately after the user modifies a Parameter value. In this case an evaluation can be forced by invoking evaluate().\n\nThe most important function for a Model object is fit!(), which allows to fit the model against an empirical dataset. The ! in the name reminds us that, after fitting, the parameter values will be set to the best fit ones (rather than retaining their original values).\n\nThe model and all component evaluation can be obtained by using the Model object has if it was a function: with no arguments it will return the main component evaluation, while if a Symbol is given as argument it will return the evaluation of the component with the same name.\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.MultiModel","page":"API","title":"GFit.MultiModel","text":"MultiModel\n\nA structure containing a multi-model description, whose evaluation is suitable to be compared to a set of empirical datasets. A MultiModel is very similar to a vector of Model objects, with the ability to trasparently handle the patch constraints between one model and the other.\n\nConstructor is: MultiModel(model1, model2, ...).\n\nYou may access the individual Model objects the indexing syntax, as if it was a Vector{Model}.  Also, you may add new model to a MultiModel after it has been created using the push!() function. Finally, you may retrieve the length of the vector with length().\n\nJust like a Model object you may need to manually trigger a MultiModel evaluation using the evaluate() function.\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.@λ","page":"API","title":"GFit.@λ","text":"@λ expr\n\nMacro to generate λFunct objects using the same syntax as in a standard Julia anonymous function. Example: @λ (x, f) -> f .* x\n\n\n\n\n\n","category":"macro"},{"location":"api/#GFit.axis","page":"API","title":"GFit.axis","text":"axis(d::CartesianDomain, dim::Integer)\n\nReturns the coordinates of the grid along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.coords","page":"API","title":"GFit.coords","text":"coords(d::Domain{1})\ncoords(d::Domain, dim::Integer)\ncoords(d::CartesianDomain, dim::Integer)\n\nReturns coordinates of all points along a given dimension as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.domain","page":"API","title":"GFit.domain","text":"domain(model::Model)\n\nReturn the domain where the model is evaluated.\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.evaluate","page":"API","title":"GFit.evaluate","text":"evaluate(model::Model)\n\nEvaluate a Model and update internal structures.\n\n\n\n\n\nevaluate(multi::MultiModel)\n\nEvaluate a MultiModel and update internal structures.\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.fit!","page":"API","title":"GFit.fit!","text":"fit!(model::Model, data::Measures, mzer::AbstractMinimizer=lsqfit())\n\nFit a model to an empirical data set using the specified minimizer (default: lsqfit()).\n\n\n\n\n\nfit!(multi::MultiModel, data::Vector{Measures{N}}, mzer::AbstractMinimizer=lsqfit())\n\nFit a multi-model to a set of empirical data sets using the specified minimizer (default: lsqfit()).\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.freeze!","page":"API","title":"GFit.freeze!","text":"freeze!(model::Model, cname::Symbol)\n\nFreeze a component in the model (i.e. treat all component parameters as fixed for fitting).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.getindex","page":"API","title":"Base.getindex","text":"getindex(d::Union{Domain, CartesianDomain}, dim::Integer)\n\nShortcut for coords(d, dim).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.haskey","page":"API","title":"Base.haskey","text":"haskey(m::Model, name::Symbol)\n\nCheck whether a component exists in model.\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.isfreezed","page":"API","title":"GFit.isfreezed","text":"isfreezed(model::Model, cname::Symbol)\n\nCheck whether a component is freezed in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length","page":"API","title":"Base.length","text":"length(multi::MultiModel)\n\nReturns how many Model objects are contained in a MultiModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.push!","page":"API","title":"Base.push!","text":"push!(multi::MultiModel, model::Model)\n\nPush a new Model object into a MultiModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.select_maincomp!","page":"API","title":"GFit.select_maincomp!","text":"select_maincomp!(model::Model, cname::Symbol)\n\nForce a component to be the final one for model evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.thaw!","page":"API","title":"GFit.thaw!","text":"thaw!(model::Model, cname::Symbol)\n\nThaw a freezed component in the model (i.e. treat component parameters as fixed only if explicitly set in the corresponding Parameter structure).\n\n\n\n\n\n","category":"function"},{"location":"api/#GFit.uncerts","page":"API","title":"GFit.uncerts","text":"uncerts(d::Measures)\n\nReturns the measurement uncertainties as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.values","page":"API","title":"Base.values","text":"values(d::Measures)\n\nReturns the measurement values as a Vector{Float64}.\n\n\n\n\n\n","category":"function"},{"location":"api/#Non-exported-symbols","page":"API","title":"Non-exported symbols","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following symbols are not exported by the GFit.jl package since they are typically not used in every day work, or aimed to debugging purposes.  Still, they can be useful in some case, hence they are documented here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"GFit.FitResult\nGFit.λFunct\nGFit.Parameter\nGFit.mock","category":"page"},{"location":"api/#GFit.FitResult","page":"API","title":"GFit.FitResult","text":"FitResult\n\nA structure representing the results of a fitting process.\n\nFields:\n\ntimestamp::DateTime: time at which the fitting process has started;\nelapsed::Float64: elapsed time (in seconds);\nndata::Int: number of data empirical points;\nnfree::Int: number of free parameters;\ndof::Int: ndata - nfree;\nfitstat::Float64: fit statistics (equivalent ro reduced χ^2 for Measures objects);\nstatus: minimizer exit status (tells whether convergence criterion has been satisfied, or if an error has occurred during fitting);\nbestfit: dictionary of Parameter objects containing best fit values and their 1-σ uncertainties.  In the multi-model case this will be a vector of dictionaries.\n\nNote: the FitResult fields are supposed to be accessed directly by the user, without invoking any get/set method.\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.λFunct","page":"API","title":"GFit.λFunct","text":"λFunct\n\nA representation for a λ function, containing a reference to the function itself, a string representation of its source code (for displaying purposes) and a list of its arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.Parameter","page":"API","title":"GFit.Parameter","text":"Parameter\n\nA structure representing a model parameter.\n\nFields:\n\nval::Float64: parameter value (either initial guess when set before fitting, or best fit one after fitting);\nlow::Float64: lower limit for the value (default: -Inf);\nhigh::Float64: upper limit for the value (default: +Inf);\nfixed::Bool: whether the parameter is fixed during fitting (default: false);\npatch::Union{Nothing, Symbol, λFunct}: patch prescription within the same model;\nmpatch::Union{Nothing, λFunct}: patch prescription in a multi-model analysis;\nactual::Float64: actual value for the parameter (i.e. after applying the patch prescription)`;\nunc::Float64: 1σ uncertainty associated to the parameter value.\n\nNote: the Parameter fields are supposed to be accessed directly by the user, without invoking any get/set method.\n\n\n\n\n\n","category":"type"},{"location":"api/#GFit.mock","page":"API","title":"GFit.mock","text":"mock(::Type{Measures}, model::Model; keywords...)\nmock(::Type{Measures}, multi::MultiModel; keywords...)\n\nGenerate mock dataset(s) using a ground truth Model or MultiModel object. The first version returns a single Measures object, while the second returns a Vector{Measures}.\n\nThe measurement random errors added to the data points are drawn from a Normal distribution centered on the data value itself, and a width given by the sum of three contributions:\n\nproportional part: error proportional to each data point value;\nrange part: error proportional to the range spanned by all values in a single dataset;\nabsolute part: absolute error value.\n\nNo systematic error is considered when generating mock dataset(s).\n\nAccepted keywords:\n\nproperr=0.01: proportional error;\nrangeerr=0.05: range error;\nabserr=0.: absolute error;\nseed=nothing: seed for the Random.MersenneTwister generator.\n\n\n\n\n\n","category":"function"},{"location":"concepts/#Basic-concepts-and-data-types","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"","category":"section"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"In order to exploit the GFit.jl model expressiveness we need to introduce a few concepts, and the associated data types:","category":"page"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Domain: an N-dimensional grid of points where the model is to be evaluated, it is analogous to the independent varible vecx in the f(vecx) notation. It is represented by either:\na Domain{N} object for linear domains, i.e. where the coordinates for each of the N dimensions are explicitly specified for all the points;\nor a CartesianDomain{N} object where the coordinates are specified for each of the N axis and the coordinates for all points are obtained as the cartesian product of the axis.  A carteisan domain is internally transformed into a linear one when needed;\nA domain object (either linear or cartesian) is required as first argument for the Model and Measures constructors (see below). However only the former is actually used during evaluation, while the latter is only used for visualization and consistency checks.\nMeasures: a container for the N-dimensional empirical data and their associated 1sigma Gaussian uncertainties, represented by an object of type Measures{N} (further options may be available in the future, such as Poisson counts);\nModel component: the atomic building block of a (potentially very complex) model, it is essentially a function used to map a Domain or CartesianDomain object into a Vector{Float64} represeting the component evaluation.  All components are structures inheriting from GFit.AbstractComponent and are typically parametrized (see below).  The GFit.jl package provides several Built-in components, and new ones can be implemented by the user.  The caching mechanism operates at the component level and aims to avoid unnecessary re-evaluation of the component if none has of its parameter values has changed since last evaluation;\nParameter: a floating point value characterizing a specific aspect for the evaluation of a model component, e.g. the slope of a power law or the width of a Gaussian profile.  The parameter values are changed during the fitting process until the residuals between the global model evaluation and the empirical data are minimized.  A parameter can be fixed to a specific value, limited in an interval, and/or be dynamically calculated (patched) according to the values of other parameters.  All parameters are represented by an object of type GFit.Parameter;\nModel: is the overall model description, whose evaluation is supposed to be compared to a single Measures objects and whose parameters are varied during fitting to reduce the residuals. All models are represented by an object of type Model containing a single Domain or CartesianDomain object representing the domain where the model will be evaluated, and one or more components characterizing the model itself.  Each component is identified by a unique name (actually a Symbol) within a model.\nMain component of a model: the evaluation of a component, say A, may use the output of another component, say B, to calculate its output.  In this case we say tha A depends on B, and therefore B needs to be evaluated before A (circular dependencies are not allowed, and would raise an error if attempted).  The dependencies are automatically identified, and the last component being evaluated is dubbed main component since it is its output which represent the overall model evaluation;\nMulti-model: a container for two or more models, suitable to be compared to a corresponding number of Measures objects to perform multi-dataset fitting.  All models are identified by a unique integer identifier, starting from 1.  A multi-model is represented by an object of type MultiModel;\nFit results: the purpose of fitting is to minimize the distance between the model and the data, as quantified by a proper fit statistic (typically a reduced chi^2 for the Gaussian uncertainties case). Such statistic, as well as other information concerning the fit and the best fit parameter values and uncertainties, are returned by the fit!() function in a GFit.FitResult structure.\nλ-function: is an anonymous function used in two different contexts within GFit.jl:\nto calculate the value of a Parameter as a function of other Parameter's values. In this case the parameters are said to be patched, or linked, since there is a constraint between their values.  Two (or more) parameters may be patched within the same model, or across models in a multi-model analysis;\nto define a model component using a standard Julia mathematical expression involving Parameters values or other components.\nIn both cases the λ-function is generated using the @λ macro and the standard Julia syntax for anonymous functions (e.g. @λ x -> 2 .* x).\nMinimizer: the GFit.jl package provides just the tools to define and manipulate a model, but the actual fitting (or minimization of the residuals) is performed by an external minimizer library.  Two minimizers are currently available:\nLsqFit: a pure-Julia minimizer;\nCMPFit: a C minimizer wrapped in a Julia package.\nBoth are automatically installed with GFit.jl, and LsqFit is the default choice (unless otherwise specified in the fit!() function call).  However, for the most complex cases CMPFit seems to be more robust and less sensitive to initial guess parameters.\nMock data: sometimes it is useful to test a model even before actual data are available, e.g. to test its robustness and capabilities.  In this case it is possible to generate mock data set(s) using the model as ground truth, and add a random noise to simulate the measurement process. This  functionality is provided by the GFit.mock() function, and will be used in all the examples presented in the next sections.","category":"page"},{"location":"concepts/#Usage","page":"Basic concepts and data types","title":"Usage","text":"","category":"section"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Many of the above mentioned data structures are accessible using either indexing (as in dictionary or vectors) or a struct-like interface, hence it is important to keep in mind the relationships among some of the concepts to access them:","category":"page"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"Multi-model (`multi`)\n |\n + -- Model 1 (`model`)\n |     |\n |     + -- Domain\n |     + -- Component1\n |     |     |\n |     |     + -- Param1\n |     |     + -- Param2\n |     |     + -- ...\n |     + -- Component2\n |     + -- etc.\n + -- Model2\n + -- ...","category":"page"},{"location":"concepts/","page":"Basic concepts and data types","title":"Basic concepts and data types","text":"E.g. the syntax to access the value of a parameter in a single model case is: model[:Component1].Param1.val.  In a multi-model case it is: multi[1][:Component1].Param1.val. ```","category":"page"},{"location":"examples/#Examples:","page":"Examples","title":"Examples:","text":"","category":"section"},{"location":"examples/#D:-offset-two-Gaussian-profiles","page":"Examples","title":"1D: offset + two Gaussian profiles","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"x = Domain(1:0.05:10)\nmodel = Model(x,\n    :offset => 4,\n    :line1  => GFit.Gaussian(1.1 , 4.4, 0.51),\n    :line2  => GFit.Gaussian(0.52, 5.5, 1.2 ))\n\nusing Random\nrng = MersenneTwister(0);\nnoise = maximum(model()) * 0.01\ndata = Measures(model() + noise * randn(rng, length(model())), noise);\nret1 = fit!(model, data)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To produce the plots I will use the Gnuplot.jl package, but the user can choose any other package:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gnuplot\n@gp    \"set multi layout 2,1\" :-\n@gp :- domain(model) data.val data.unc \"w yerr tit 'Data'\" :-\n@gp :- domain(model) model(:line1) .+ model(:offset) \"w l tit 'offset + line1'\" :-\n@gp :- domain(model) model(:line2) .+ model(:offset) \"w l tit 'offset + line2'\" :-\n@gp :- domain(model) model() \"w lines tit 'Model' lw 3\" :-\n@gp :- 2 x[1] (data.val - model()) ./ data.unc fill(1., length(data)) \"w yerr tit 'Residuals'\"","category":"page"},{"location":"examples/#D:-tilted-plane-2D-Gaussian-profile","page":"Examples","title":"2D: tilted plane + 2D Gaussian profile","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"dom = CartesianDomain(-5:0.1:5, -4:0.1:4)\nmodel = Model(dom,\n              :background => GFit.OffsetSlope(0, 0, 0., 2., 3.),\n              :psf => GFit.Gaussian(100., 0., 0., 1, 0.3, 15))\n\n\nnoise = maximum(model()) * 0.1\ndata = Measures(model() .+ 4 .+ noise .* randn(length(model())), noise);\nret1 = fit!(model, data)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To produce the plots I will use the Gnuplot.jl package, but the user can choose any other package:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Gnuplot\n\n# Plot the model...\n@gsp dom[1] dom[2] reshape(model(), dom)\n\n# ...and the residuals\n@gsp dom[1] dom[2] reshape(data.val - model(), dom)\n\n# Plot using pm3d style\n@gsp \"set pm3d\" \"set palette\" dom[1] dom[2] reshape(model(), dom) \"w dots\"","category":"page"},{"location":"builtincomp/#Built-in-components","page":"Built-in components","title":"Built-in components","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The following components are available in the GFit module:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"FuncWrap: a Julia function wrapper;\nSimplePar: a scalar parameter;\nCDomain: use a model domain as a component;\nOffsetSlope (1D and 2D): an offset and slope component;\nPolynomial (only 1D): a n-th degree polynomial function (n > 1);\nGaussian (1D and 2D): a Gaussian function;\nLorentzian (1D and 2D): a Lorentzian function;","category":"page"},{"location":"builtincomp/#Funcwrap","page":"Built-in components","title":"Funcwrap","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The FuncWrap is simply a wrapper to a user defined function of the form f(x, [y], [z], [further dimensions...], p1, p2, [further parameters...]).  The x, y, z arguments will be Vector{Float64} with the same number of elements, while p1, p2, etc. will be scalar floats.  The function must return a Vector{Float64} (regardless of thenumber of dimensions) with the same number of elements as x.  This components works with domains of any dimensionality.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructor is defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"FuncWrap(func::Function, args...)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"where args... is a list of numbers.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"p::Vector{Parameter}: vector of parameters for the user defined function.","category":"page"},{"location":"builtincomp/#SimplePar","page":"Built-in components","title":"SimplePar","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The SimplePar represent a scalar component in the model, whose value is given by the val parameter.  This components works with domains of any dimensionality.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructor is defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"SimplePar(val::Number)","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"val::Parameter: the scalar value.","category":"page"},{"location":"builtincomp/#OffsetSlope","page":"Built-in components","title":"OffsetSlope","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"An offset and slope component for 1D and 2D domains.  In 2D it represents a tilted plane.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D: GFit.Components.OffsetSlope(offset, x0, slope);\n2D: GFit.Components.OffsetSlope(offset, x0, y0, slopeX, slopeY);","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslope::Parameter: the slope of the linear function;\n2D:\noffset::Parameter: a global offset;\nx0::Parameter: the X coordinate of the point where the component equals offset.  This parameter is fixed by default;\ny0::Parameter: the Y coordinate of the point where the component equals offset.  This parameter is fixed by default;\nslopeX::Parameter (only 2D): the slope of the plane along the X direction;\nslopeY::Parameter (only 2D): the slope of the plane along the Y direction;","category":"page"},{"location":"builtincomp/#Polynomial","page":"Built-in components","title":"Polynomial","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A n-th degree polynomial function (n > 1) for 1D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructor is defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"GFit.Components.Polynomial(args...); where args... is a list of numbers.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"coeff::Vector{Parameter}: vector of polynomial coefficients.","category":"page"},{"location":"builtincomp/#Gaussian","page":"Built-in components","title":"Gaussian","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A normalized Gaussian component for 1D and 2D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D: GFit.Components.Gaussian(norm, center, sigma);\n2D: GFit.Components.Gaussian(norm, centerX, centerY, sigma) (implies sigmaX=sigmaY, angle=0);\n2D: GFit.Components.Gaussian(norm, centerX, centerY, sigmaX, sigmaY, angle);","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D:\nnorm::Parameter: the area below the Gaussian function;\ncenter::Parameter: the location of the center of the Gaussian;\nsigma::Parameter: the width the Gaussian;\n2D:\nnorm::Parameter: the volume below the Gaussian function;\ncenterX::Parameter: the X coordinate of the center of the Gaussian;\ncenterY::Parameter: the Y coordinate of the center of the Gaussian;\nsigmaX::Parameter: the width the Gaussian along the X direction (when angle=0);\nsigmaY::Parameter: the width the Gaussian along the Y direction (when angle=0);\nangle::Parameter: the rotation angle of the whole Gaussian function.","category":"page"},{"location":"builtincomp/#Lorentzian","page":"Built-in components","title":"Lorentzian","text":"","category":"section"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"A Lorentzian component for 1D and 2D domains.","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The constructors are defined as follows:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D: GFit.Components.Lorentzian(norm, center, fwhm);\n2D: GFit.Components.Lorentzian(norm, centerX, centerY, fwhmX, fwhmY);","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"The parameters are:","category":"page"},{"location":"builtincomp/","page":"Built-in components","title":"Built-in components","text":"1D:\nnorm::Parameter: the area below the Lorentzian function;\ncenter::Parameter: the location of the center of the Lorentzian;\nfwhm::Parameter: the full-width at half maximum of the Lorentzian;\n2D:\nnorm::Parameter: the volume below the Lorentzian function;\ncenterX::Parameter: the X coordinate of the center of the Lorentzian;\ncenterY::Parameter: the Y coordinate of the center of the Lorentzian;\nfwhmX::Parameter: the full-width at half maximum of the Lorentzian along the X direction (when angle=0);\nfwhmY::Parameter: the full-width at half maximum of the Lorentzian along the Y direction (when angle=0).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GFit, Gnuplot\nGnuplot.quitall()\nsaveas(file) = Gnuplot.save(term=\"pngcairo size 550,350 fontscale 0.8\", output=\"assets/$(file).png\")","category":"page"},{"location":"#Gfit.jl","page":"Home","title":"Gfit.jl","text":"","category":"section"},{"location":"#A-model-fitting-framework-for-Julia.","page":"Home","title":"A model fitting framework for Julia.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stars)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gfit.jl is a general purpose, data-driven model fitting framework for Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides the basic tools to define, interactively manipulate and efficiently evaluate a (possibly very complex) model, and to fit the latter to empirical data. The main functionalities are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"it handles datasets of any dimensionality;\nthe syntax is very simple and concise as it resembles the indexing for dictionaries and the field access for structs.  The most relevant functions are the self-explanatory fit!() and the object constructors (see Basic concepts and data types);\nthe fitting model is evaluated on a user defined domain, and is the result of a combination of model components or mathematical expressions (in the form of lambda functions), or any arbitrary mixture of the two;\nit allows to define new model components to suit specific needs;\nmodel parameters can be fixed to a specific value, limited in an interval, and/or be dynamically linked (patched) to the values of other parameters;\nmultiple data sets can be fitted simultaneously against different models whose parameters can optionally be patched;\nall components results are cached so that repeated evaluations with the same parameter values do not involve further calculations;\nuser provided components can pre-compute quantities based on the model domain, and store them in reserved areas for re-use;\nit support different minimizers (LsqFit and CMPFit);\nit provides several facilities for interactive fitting and result displaying.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The fitting process is actually a non-linear least square regression, and is  carried out by one of the above mentioned minimizer packages, whose purpose is to automatically vary the parameter values (according to the user defined constraints) until the differences between the evaluated model and the empirical data are minimized.  The purpose of Gfit.jl is thus to act as an interface between the high-level model facing the user, and the low-level implementation details facing the minimizer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the purpose of GFit.jl is to allow easy manipulation of complex models, and that there may be little advantage in using it for a simple linear regression or for models involving just a single parameter, although it is definitely possible to use it also in these cases.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add GFit","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ] character starts the Julia package manager. Hit backspace key to return to Julia prompt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to easily visualize the outcomes of 1D analysis you may be interested in installing also GFitViewer and/or Gnuplot.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add GFitViewer\njulia> ]add Gnuplot","category":"page"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The typical workflow to use GFit.jl is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Wrap empirical data domain and measures into one (ore more) Domain and Measures object(s);\nCreate a Model object and build it by adding components or mathematical expressions, each representing a specific aspect of the theoretical model;\nOptionally set initial guess parameter values, define constraints between model parameters, etc.;\nFit the model against the data and inspect the results;\nIf needed, modify the model and repeat the fitting process;\nExploit the results and outputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A very simple example showing the above workflow is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GFit\n\n# Prepare vectors with domain points, empirical measures an their uncertainties and\n# use them to create the GFit input objects:\nx    = [0.1, 1.1, 2.1, 3.1, 4.1]\nmeas = [6.29, 7.27, 10.41, 18.67, 25.3]\nunc  = [1.1, 1.1, 1.1, 1.2, 1.2]\ndom  = Domain(x)\ndata = Measures(dom, meas, unc)\n\n# Create a model using an explicit mathematical expression, and provide the\n# initial guess values:\nmodel = Model(dom, @λ (x, a2=1, a1=1, a0=5) -> (a2 .* x.^2  .+  a1 .* x  .+  a0))\n\n# Fit model to the data\nres = fit!(model, data)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The GFit.jl package implements a show method for many of the data types involved, hence the above code results in the following output:","category":"page"},{"location":"","page":"Home","title":"Home","text":"show(res) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing the best fit parameter values and the associated uncertaintites, as well as a few statistics concerning the fitting process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If not saitisfied with the result you may, for instance, change the initial value for a parameter and re-run the fit:","category":"page"},{"location":"","page":"Home","title":"Home","text":"model[:main].a0.val = 5\nres = fit!(model, data)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once done, you may plot the data and the best fit model with a plotting framework of your choice. E.g., with Gnuplot.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Gnuplot\n@gp coords(dom) values(data) uncerts(data) \"w yerr t 'Data'\" :-\n@gp :- coords(domain(model)) model() \"w l t 'Best fit model'\"\nsaveas(\"simple_example\") # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, you can easily access the numerical results for further analysis, e.g.:","category":"page"},{"location":"","page":"Home","title":"Home","text":"println(\"Best fit value for the offset parameter: \", \n\tres.bestfit[:main].a0.val, \" ± \", \n\tres.bestfit[:main].a0.unc, \"\\n\",\n\t\"Reduced χ^2: \", res.fitstat)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above example is definitely a simple one, but even more complex ones follow the same workflow.","category":"page"},{"location":"viewers/#Viewers-for-the-1-dim-case","page":"Viewers","title":"Viewers for the 1-dim case","text":"","category":"section"}]
}
