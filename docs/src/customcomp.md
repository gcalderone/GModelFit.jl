```@setup abc
include("setup.jl")
```

# Custom components

Besides the [Built-in components](@ref), the user may define any number of custom components to be used in a model.  Before continuing be sure to read the [GModelFit internals](@ref) section.

A user-defined component shall satisfy the following three constraints:

- It shall be a structure inheriting from `GModelFit.AbstractComponent`;

- The component parameters (if present) shall be defined as fields with type `Parameter`, e.g.:
  ```julia
  struct MyComponent <: AbstractComponent
      param1::Parameter
      param2::Parameter
      ...
  end
  ```
  (see below for a complete example).   Alternatively, the parameters may be specified as a single field of type `OrderedDict{Symbol, Parameter}` (see the [`Polynomial`](https://github.com/gcalderone/GModelFit.jl/blob/master/src/components/Polynomial.jl) component for an example).  The structure may also contain further fields of any type;

- The [`GModelFit.evaluate!`](@ref) function shall be extended to provide the component-specific code for evaluation.  Specifically, it should replace the content of the `CompEval.buffer` vector with the outcome of the new component evaluation, using the parameter values provided as arguments, e.g.
  ```julia
  function evaluate!(ceval::CompEval{MyComponent},
                     param1::Float64, param2::Float64...)
    ceval.buffer .= (component evaluation using param1 and param2 values)
  end
  ```


Optionally, the user may choose to extend also the following functions:
- [`GModelFit.prepare!`](@ref): to prepare the component for evaluations on a specific domain (e.g. to pre-compute quantities which depend only on the domain being used).  The return value must be a `Vector{Float64}` to accomodate the component evaluation, this will be used as `buffer` field of the corresponding [`GModelFit.CompEval`](@ref) structure.  If not implemented, the default  implementation will simply creates a buffer with the same length as the input domain;

- [`GModelFit.dependencies`](@ref): to specify the list of the component dependencies.  The evaluation of the latter will be made available via the `deps` field of the  [`GModelFit.CompEval`](@ref) structure.  Return value shall be a `Vector{Symbol}`, and the default implementation returns an empty list `Symbol[]`.


### Life cycle of a component

The typical life cycle of a component is as follows:
1. The component is created by invoking its constructor and is added to a [`Model`](@ref) object before any evaluation;
1. The user may optionally modify the component parameter initial values, as well as their [Parameter constraints](@ref), before starting the fit;
1. When the [`fit`](@ref) function is invoked, all components in a `Model` are wrapped into [`GModelFit.CompEval`](@ref) objects, and the latter are collected into a [`GModelFit.ModelEval`](@ref) object (also containing the original `Model`);
1. During the creation of the `CompEval` object the component [`GModelFit.prepare!`](@ref) function is called to allocate the proper buffer for evaluations.  Note that the `prepare!` function is invoked only once for each `fit` invocation, hence it is the perfect place to pre-compute quantities which will be used during the component evaluation.  The domain for component evaluation is obtained from the [`Measures`](@ref) object provided as argument to the `fit` function;
1. During the creation of the [`GModelFit.ModelEval`](@ref) object a a dependency tree is generated by invoking the [`GModelFit.dependencies`](@ref) function for all components. The tree is used to identify the proper order for component evaluations: the leaves will be evaluated first, and the remaining ones will be evaluated following the tree branches up to the root, dubbed *main component*.  The evaluation of the latter will be compared to the data;
1. During the fitting process the component [`GModelFit.evaluate!`](@ref) function is invoked whenever a change in its parameter values is detected, until a convergence criterion is satisfied.


### Example

A common case is to compare empirical data with a numerically evaluated theoretical model, possibly defined on a different grid with respect to the empirical one.  An interpolation is therefore required in order to compare the model to the data.

Let's assume the theoretical model is defined as follows:
```@example abc
theory_x = 0.:10
theory_y = [0, 0.841, 0.909, 0.141, -0.757, -0.959, -0.279, 0.657, 0.989, 0.412, -0.544]
println() # hide
```
while the empirical data are:
```@example abc
obs_x = [0.500, 2.071, 3.642, 5.212, 6.783, 8.354, 9.925]
obs_y = [2.048, 3.481, 1.060, 0.515, 3.220, 4.398, 1.808]
println() # hide
```

The following example shows how to implement a component which interpolates a theoretical model onto a specific empirical domain, with the only parameter being a global scaling factor:
```@example abc
using GModelFit, Interpolations
import GModelFit.prepare!, GModelFit.evaluate!

# Define the component structure and constructor
struct Interpolator <: GModelFit.AbstractComponent
    theory_x::Vector{Float64}
    theory_y::Vector{Float64}
    interp_y::Vector{Float64}  # will contain the interpolated values
    scale::GModelFit.Parameter

    function Interpolator(theory_x, theory_y)
        scale = GModelFit.Parameter(1)
        scale.low = 0                  # ensure scale parameter is positive
        interp_y = Vector{Float64}()   # this will be populated in prepare!()
        return new(theory_x, theory_y, interp_y, scale)
    end
end

# Component preparation: invoked only once to precompute quantities
# and allocate evaluation buffer
function prepare!(comp::Interpolator, domain::AbstractDomain{1})
    # Pre-compute interpolation on the empirical domain
    itp = linear_interpolation(comp.theory_x, comp.theory_y)
    append!(comp.interp_y, itp(coords(domain)))
    return fill(NaN, length(comp.interp_y)) # buffer for evaluations
end

# Component evaluation (apply scaling factor)
function evaluate!(ceval::GModelFit.CompEval{Interpolator, <: AbstractDomain{1}},
                   scale)
    ceval.buffer .= scale .* ceval.comp.interp_y
end
println() # hide
```

The following code shows how to prepare a `Model` including the interpolated theoretical model, and to take into account the possible background introduced by the detector used to obtain empirical data:
```@example abc
model = Model(:theory => Interpolator(theory_x, theory_y),
              :background => GModelFit.OffsetSlope(1., 0., 0.2),
              :main => SumReducer(:theory, :background))

data = Measures(Domain(obs_x), obs_y, 0.2)
bestfit, stats = fit(model, data)
show((bestfit, stats)) # hide
```
